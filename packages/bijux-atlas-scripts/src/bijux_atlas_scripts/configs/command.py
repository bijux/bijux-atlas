from __future__ import annotations

import argparse
import hashlib
import json
import re
from datetime import datetime, timezone
from pathlib import Path
from typing import Callable

from ..core.context import RunContext
from ..core.fs import ensure_evidence_path
from ..core.process import run_command
from ..core.tooling import read_pins, read_tool_versions

_CONFIG_KEY_PATTERN = re.compile(r"^[A-Z][A-Z0-9_]*$")
SELF_CLI = ["python3", "-m", "bijux_atlas_scripts.cli"]


def normalize_config_key(key: str) -> str:
    normalized = key.strip().replace("-", "_").upper()
    if not _CONFIG_KEY_PATTERN.match(normalized):
        raise ValueError(f"invalid config key: {key}")
    return normalized


def _run(cmd: list[str], repo_root: Path) -> tuple[int, str]:
    res = run_command(cmd, repo_root)
    return res.code, res.combined_output


def _collect_config_files(repo_root: Path) -> list[str]:
    files: list[str] = []
    for p in sorted((repo_root / "configs").rglob("*")):
        if not p.is_file():
            continue
        if p.suffix not in {".json", ".yaml", ".yml", ".toml", ".md"}:
            continue
        files.append(p.relative_to(repo_root).as_posix())
    return files


def _ownership_map(repo_root: Path) -> dict[str, str]:
    path = repo_root / "configs/_meta/ownership.json"
    payload = json.loads(path.read_text(encoding="utf-8"))
    return {str(k): str(v) for k, v in payload.get("areas", {}).items()}


def _inventory_payload(repo_root: Path) -> dict[str, object]:
    owners = _ownership_map(repo_root)
    rows: list[dict[str, str]] = []
    for rel in _collect_config_files(repo_root):
        owner = "unknown"
        for area, area_owner in owners.items():
            if rel == area or rel.startswith(area + "/"):
                owner = area_owner
                break
        rows.append({"path": rel, "owner": owner})
    return {"schema_version": 1, "kind": "configs-inventory", "files": rows}


def _generate_configs_index(repo_root: Path) -> Path:
    out = repo_root / "docs/_generated/configs-index.md"
    payload = _inventory_payload(repo_root)
    lines = [
        "# Configs Index",
        "",
        "Generated by `bijux-atlas configs index`.",
        "",
        "| Path | Owner |",
        "|---|---|",
    ]
    for row in payload["files"]:
        lines.append(f"| `{row['path']}` | `{row['owner']}` |")
    out.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return out


def _naming_check(repo_root: Path) -> tuple[int, str]:
    bad: list[str] = []
    allowed = re.compile(r"^[a-z0-9._/-]+$")
    for rel in _collect_config_files(repo_root):
        if not allowed.match(rel):
            bad.append(rel)
    if bad:
        return 1, "config naming check failed:\n" + "\n".join(f"- {x}" for x in bad)
    return 0, "config naming check passed"


def _schema_check(repo_root: Path) -> tuple[int, str]:
    checks = [
        ["python3", "scripts/areas/configs/check_config_files_well_formed.py"],
        ["python3", "scripts/areas/configs/validate_configs_schemas.py"],
    ]
    output_lines: list[str] = []
    for cmd in checks:
        code, out = _run(cmd, repo_root)
        if out:
            output_lines.append(out)
        if code != 0:
            return code, "\n".join(output_lines)
    return 0, "\n".join(output_lines) or "config schema check passed"


def _read_json(repo_root: Path, rel: str) -> dict[str, object]:
    return json.loads((repo_root / rel).read_text(encoding="utf-8"))


def _config_print(repo_root: Path) -> tuple[int, str]:
    sources = [
        "configs/policy/policy.json",
        "configs/ops/env.schema.json",
        "configs/ops/tool-versions.json",
        "configs/ops/observability-pack.json",
        "configs/perf/k6-thresholds.v1.json",
        "configs/slo/slo.json",
    ]
    provenance = []
    for src in sources:
        raw = (repo_root / src).read_bytes()
        provenance.append({"path": src, "sha256": hashlib.sha256(raw).hexdigest()})
    payload = {
        "policy": _read_json(repo_root, "configs/policy/policy.json"),
        "ops_env_schema": _read_json(repo_root, "configs/ops/env.schema.json"),
        "ops_tool_versions": _read_json(repo_root, "configs/ops/tool-versions.json"),
        "ops_pins": read_pins(repo_root),
        "ops_observability_pack": _read_json(repo_root, "configs/ops/observability-pack.json"),
        "perf_thresholds": _read_json(repo_root, "configs/perf/k6-thresholds.v1.json"),
        "slo": _read_json(repo_root, "configs/slo/slo.json"),
        "_provenance": provenance,
    }
    return 0, json.dumps(payload, indent=2, sort_keys=True)


def _config_drift(repo_root: Path) -> tuple[int, str]:
    errors: list[str] = []
    policy_schema = _read_json(repo_root, "configs/policy/policy.schema.json")
    contracts_policy = _read_json(repo_root, "docs/contracts/POLICY_SCHEMA.json")
    if policy_schema != contracts_policy:
        errors.append("policy schema drift between configs and docs/contracts")

    key_doc = repo_root / "configs/config-key-registry.md"
    if not key_doc.exists():
        errors.append("missing generated configs/config-key-registry.md (run make config-validate)")
    else:
        keys = _read_json(repo_root, "docs/contracts/CONFIG_KEYS.json").get("env_keys", [])
        text = key_doc.read_text(encoding="utf-8")
        for key in keys:
            try:
                normalized_key = normalize_config_key(str(key))
            except ValueError as exc:
                errors.append(str(exc))
                continue
            if f"`{normalized_key}`" not in text:
                errors.append(f"config key registry missing `{key}`")
                break
    if errors:
        return 1, "config drift check failed:\n" + "\n".join(f"- {err}" for err in errors)
    return 0, "config drift check passed"


def _config_validate(repo_root: Path) -> tuple[int, str]:
    return _run(["python3", "scripts/areas/public/config-validate.py"], repo_root)


def run_configs_command(ctx: RunContext, ns: argparse.Namespace) -> int:
    repo = ctx.repo_root
    report = ns.report
    started_at = datetime.now(timezone.utc).isoformat()

    if ns.configs_cmd == "inventory":
        payload = _inventory_payload(repo)
        if getattr(ns, "format", "json") == "md":
            out = _generate_configs_index(repo)
            result = {"schema_version": 1, "output": out.relative_to(repo).as_posix(), "tool": "bijux-atlas"}
        else:
            result = payload
        print(json.dumps(result, sort_keys=True) if report == "json" else json.dumps(result, indent=2, sort_keys=True))
        return 0

    command_map: dict[str, Callable[[Path], tuple[int, str]]] = {
        "print": _config_print,
        "drift": _config_drift,
        "validate": _config_validate,
        "schema-check": _schema_check,
        "no-shadow-check": lambda r: _run(
            [
                *SELF_CLI,
                "run",
                "./packages/bijux-atlas-scripts/src/bijux_atlas_scripts/layout/no_shadow.py",
            ],
            r,
        ),
        "keys-doc-check": lambda r: _run(["python3", "scripts/areas/configs/check_config_keys_docs_coverage.py"], r),
        "tool-versions": lambda r: (
            0,
            json.dumps(read_tool_versions(r), sort_keys=True),
        ),
        "naming-check": _naming_check,
        "directory-budgets-check": lambda r: _run(
            [
                *SELF_CLI,
                "run",
                "./packages/bijux-atlas-scripts/src/bijux_atlas_scripts/layout/dir_budgets.py",
            ],
            r,
        ),
        "ownership-check": lambda r: _run(["python3", "scripts/areas/configs/check_config_ownership.py"], r),
        "index": lambda r: (0, _generate_configs_index(r).relative_to(r).as_posix()),
        "env-contract": lambda r: _run(["python3", "scripts/areas/docs/generate_env_vars_doc.py"], r),
    }

    if ns.configs_cmd == "check":
        steps = [
            "schema-check",
            "no-shadow-check",
            "keys-doc-check",
        ]
        failures: list[dict[str, str]] = []
        for step in steps:
            code, out = command_map[step](repo)
            if code != 0:
                failures.append({"id": step, "output": out})
                if ns.fail_fast:
                    break
        ended_at = datetime.now(timezone.utc).isoformat()
        payload = {
            "schema_version": 1,
            "tool": "bijux-atlas",
            "run_id": ctx.run_id,
            "status": "fail" if failures else "pass",
            "started_at": started_at,
            "ended_at": ended_at,
            "failed_count": len(failures),
            "checks": failures,
        }
        if ns.emit_artifacts:
            out_path = ensure_evidence_path(ctx, ctx.evidence_root / "configs" / "check" / ctx.run_id / "report.json")
            out_path.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")
        print(json.dumps(payload, sort_keys=True) if report == "json" else f"configs check: {payload['status']}")
        if failures and report != "json":
            for fail in failures:
                print(f"- FAIL {fail['id']}")
        return 0 if not failures else 1

    fn = command_map.get(ns.configs_cmd)
    if not fn:
        return 2
    code, out = fn(repo)
    ended_at = datetime.now(timezone.utc).isoformat()
    payload = {
        "schema_version": 1,
        "tool": "bijux-atlas",
        "run_id": ctx.run_id,
        "status": "pass" if code == 0 else "fail",
        "started_at": started_at,
        "ended_at": ended_at,
        "command": ns.configs_cmd,
        "output": out,
    }
    print(json.dumps(payload, sort_keys=True) if report == "json" else out)
    return code


def configure_configs_parser(sub: argparse._SubParsersAction[argparse.ArgumentParser]) -> None:
    p = sub.add_parser("configs", help="configs validation and inventory commands")
    cfg = p.add_subparsers(dest="configs_cmd", required=True)

    check = cfg.add_parser("check", help="run canonical configs checks")
    check.add_argument("--report", choices=["text", "json"], default="text")
    check.add_argument("--emit-artifacts", action="store_true")
    check.add_argument("--fail-fast", action="store_true")

    inv = cfg.add_parser("inventory", help="list config files with owners")
    inv.add_argument("--format", choices=["json", "md"], default="json")
    inv.add_argument("--report", choices=["text", "json"], default="json")

    for name in (
        "print",
        "drift",
        "validate",
        "schema-check",
        "no-shadow-check",
        "keys-doc-check",
        "tool-versions",
        "naming-check",
        "directory-budgets-check",
        "ownership-check",
        "index",
        "env-contract",
    ):
        x = cfg.add_parser(name)
        x.add_argument("--report", choices=["text", "json"], default="text")
