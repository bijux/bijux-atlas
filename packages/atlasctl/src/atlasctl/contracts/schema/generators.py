from __future__ import annotations

import json
import subprocess
from pathlib import Path

from .catalog import load_catalog, write_catalog_deterministic, write_schema_readme_deterministic
from ..checks import load_json


def generate_openapi(repo_root: Path) -> list[str]:
    out = repo_root / "configs/openapi/v1/openapi.generated.json"
    proc = subprocess.run(
        ["cargo", "run", "--quiet", "-p", "bijux-atlas-api", "--bin", "atlas-openapi", "--", "--out", str(out)],
        cwd=repo_root,
        text=True,
        capture_output=True,
        check=False,
    )
    if proc.returncode != 0:
        return [proc.stderr.strip() or "openapi generation failed"]
    return []


def generate_chart_schema(repo_root: Path) -> list[str]:
    contract = load_json(repo_root / "docs/contracts/CHART_VALUES.json")
    schema = {
        "$schema": "https://json-schema.org/draft/2020-12/schema",
        "title": "bijux-atlas chart values",
        "type": "object",
        "additionalProperties": False,
        "properties": {
            key: {"description": f"Chart values key `{key}` from SSOT contract."}
            for key in contract["top_level_keys"]
        },
    }
    out = repo_root / "ops/k8s/charts/bijux-atlas/values.schema.json"
    out.write_text(json.dumps(schema, indent=2, sort_keys=True) + "\n", encoding="utf-8")
    return []


def generate_contract_artifacts(repo_root: Path) -> list[str]:
    contracts = repo_root / "docs/contracts"
    out_gen = repo_root / "docs/_generated/contracts"
    out_gen.mkdir(parents=True, exist_ok=True)

    error_codes = load_json(contracts / "ERROR_CODES.json")["codes"]
    metrics = load_json(contracts / "METRICS.json")["metrics"]
    trace_spans = load_json(contracts / "TRACE_SPANS.json")["spans"]
    endpoints = load_json(contracts / "ENDPOINTS.json")["endpoints"]
    chart_keys = load_json(contracts / "CHART_VALUES.json")["top_level_keys"]

    core_generated_dir = repo_root / "crates/bijux-atlas-core/src/generated"
    core_generated_dir.mkdir(parents=True, exist_ok=True)
    (core_generated_dir / "mod.rs").write_text("pub mod error_codes;\n", encoding="utf-8")

    core_rust_path = core_generated_dir / "error_codes.rs"
    core_rust = [
        "// @generated by atlasctl contracts generate",
        "use serde::{Deserialize, Serialize};",
        "",
        "#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]",
        "#[non_exhaustive]",
        "pub enum ErrorCode {",
    ]
    core_rust.extend([f"    {code}," for code in error_codes])
    core_rust.extend([
        "}",
        "",
        "impl ErrorCode {",
        "    #[must_use]",
        "    pub const fn as_str(self) -> &'static str {",
        "        match self {",
    ])
    core_rust.extend([f'            Self::{code} => "{code}",' for code in error_codes])
    core_rust.extend([
        "        }",
        "    }",
        "",
        "    pub fn parse(value: &str) -> Option<Self> {",
        "        match value {",
    ])
    core_rust.extend([f'            "{code}" => Some(Self::{code}),' for code in error_codes])
    core_rust.extend(["            _ => None,", "        }", "    }", "}", "", "pub const ERROR_CODES: &[&str] = &["])
    core_rust.extend([f'    "{code}",' for code in error_codes])
    core_rust.append("];\n")
    core_rust_path.write_text("\n".join(core_rust), encoding="utf-8")

    api_rust_path = repo_root / "crates/bijux-atlas-api/src/generated/error_codes.rs"
    api_rust_path.parent.mkdir(parents=True, exist_ok=True)
    api_lines = ["// @generated by atlasctl contracts generate", "pub const API_ERROR_CODES: &[&str] = &["]
    api_lines.extend([f'    "{code}",' for code in error_codes])
    api_lines.extend(["];", "", "pub type ApiErrorCode = bijux_atlas_core::ErrorCode;", ""])
    api_rust_path.write_text("\n".join(api_lines), encoding="utf-8")

    server_gen_dir = repo_root / "crates/bijux-atlas-server/src/telemetry/generated"
    server_gen_dir.mkdir(parents=True, exist_ok=True)
    (server_gen_dir / "mod.rs").write_text(
        "// @generated by atlasctl contracts generate\npub mod metrics_contract;\npub mod trace_spans_contract;\n",
        encoding="utf-8",
    )
    metric_lines = ["// @generated by atlasctl contracts generate", "pub const CONTRACT_METRIC_NAMES: &[&str] = &["]
    metric_lines.extend([f'    "{metric["name"]}",' for metric in metrics])
    metric_lines.append("];\n")
    (server_gen_dir / "metrics_contract.rs").write_text("\n".join(metric_lines), encoding="utf-8")

    span_lines = ["// @generated by atlasctl contracts generate", "pub const CONTRACT_TRACE_SPAN_NAMES: &[&str] = &["]
    span_lines.extend([f'    "{span["name"]}",' for span in trace_spans])
    span_lines.append("];\n")
    (server_gen_dir / "trace_spans_contract.rs").write_text("\n".join(span_lines), encoding="utf-8")

    for rust_file in (
        core_generated_dir / "mod.rs",
        core_rust_path,
        api_rust_path,
        server_gen_dir / "mod.rs",
        server_gen_dir / "metrics_contract.rs",
        server_gen_dir / "trace_spans_contract.rs",
    ):
        subprocess.run(["rustfmt", str(rust_file)], cwd=repo_root, text=True, check=False)

    (out_gen / "ERROR_CODES.md").write_text(
        "# Error Codes (Generated)\n\n" + "\n".join(f"- `{code}`" for code in error_codes) + "\n",
        encoding="utf-8",
    )
    (out_gen / "METRICS.md").write_text(
        "# Metrics (Generated)\n\n"
        + "\n".join(f"- `{metric['name']}` labels: {', '.join(metric['labels'])}" for metric in metrics)
        + "\n",
        encoding="utf-8",
    )
    (out_gen / "TRACE_SPANS.md").write_text(
        "# Trace Spans (Generated)\n\n"
        + "\n".join(f"- `{span['name']}` attrs: {', '.join(span['required_attributes'])}" for span in trace_spans)
        + "\n",
        encoding="utf-8",
    )
    (out_gen / "ENDPOINTS.md").write_text(
        "# Endpoints (Generated)\n\n"
        + "\n".join(f"- `{endpoint['method']} {endpoint['path']}` telemetry: `{endpoint['telemetry_class']}`" for endpoint in endpoints)
        + "\n",
        encoding="utf-8",
    )
    (out_gen / "CHART_VALUES.md").write_text(
        "# Chart Values Keys (Generated)\n\n" + "\n".join(f"- `{key}`" for key in chart_keys) + "\n",
        encoding="utf-8",
    )
    return []


def generate_schema_samples(repo_root: Path) -> list[str]:
    out_dir = repo_root / "packages/atlasctl/tests/goldens/samples"
    out_dir.mkdir(parents=True, exist_ok=True)
    templates: dict[str, dict[str, object]] = {
        "atlasctl.check-list.v1": {
            "schema_name": "atlasctl.check-list.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "checks": [],
        },
        "atlasctl.commands.v1": {
            "schema_name": "atlasctl.commands.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "run_id": "sample-commands",
            "commands": [],
        },
        "atlasctl.explain.v1": {
            "schema_name": "atlasctl.explain.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "run_id": "sample-explain",
            "command": "help",
            "contract": "atlasctl.commands.v1",
            "purpose": "describe command behavior",
            "examples": ["atlasctl explain command help --json"],
            "aliases": [],
            "touches": [],
            "tools": [],
            "failure_modes": [],
            "effect_level": "pure",
            "run_id_mode": "not_required",
            "supports_dry_run": True,
        },
        "atlasctl.help.v1": {
            "schema_name": "atlasctl.help.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "run_id": "sample-help",
            "commands": [],
        },
        "atlasctl.output-base.v1": {
            "schema_name": "atlasctl.output-base.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "run_id": "sample-output-base-v1",
            "ok": True,
            "errors": [],
            "warnings": [],
            "meta": {},
        },
        "atlasctl.output-base.v2": {
            "schema_name": "atlasctl.output-base.v2",
            "schema_version": 2,
            "tool": "atlasctl",
            "status": "ok",
            "run_id": "sample-output-base-v2",
            "ok": True,
            "errors": [],
            "warnings": [],
            "meta": {},
            "contract_version": 2,
        },
        "atlasctl.runtime_contracts.v1": {
            "schema_name": "atlasctl.runtime_contracts.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "checks": [],
        },
        "atlasctl.suite-run.v1": {
            "schema_name": "atlasctl.suite-run.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "suite": "sample",
            "summary": {"passed": 0, "failed": 0, "skipped": 0, "duration_ms": 0},
            "results": [],
            "target_dir": "artifacts/isolate/sample",
        },
        "atlasctl.surface.v1": {
            "schema_name": "atlasctl.surface.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "run_id": "sample-surface",
            "commands": [],
            "path_owners": {},
        },
        "atlasctl.check-taxonomy.v1": {
            "schema_name": "atlasctl.check-taxonomy.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "checks": [
                {
                    "id": "repo.module_size",
                    "domain": "repo",
                    "category": "hygiene",
                    "severity": "error",
                    "tags": ["repo", "required"],
                    "owners": ["platform"],
                }
            ],
        },
        "atlasctl.suite-manifests.v1": {
            "schema_name": "atlasctl.suite-manifests.v1",
            "schema_version": 1,
            "tool": "atlasctl",
            "status": "ok",
            "markers": ["required", "ci", "local", "slow"],
            "suites": [
                {
                    "name": "required",
                    "markers": ["required"],
                    "required_env": ["PYTHONPATH"],
                    "default_effects": ["read", "process"],
                    "time_budget_ms": 300000,
                }
            ],
        },
        "atlasctl.ops.manifest.v1": {
            "schema_name": "atlasctl.ops.manifest.v1",
            "schema_version": 1,
            "name": "sample-ops-manifest",
            "description": "sample manifest payload",
            "steps": [
                {
                    "id": "sample-step",
                    "command": ["echo", "ok"],
                    "allow_failure": False,
                }
            ],
        },
    }
    errors: list[str] = []
    for schema_name in sorted(load_catalog().keys()):
        payload = templates.get(schema_name)
        if payload is None:
            errors.append(f"missing sample template for schema {schema_name}")
            continue
        name = schema_name.removeprefix("atlasctl.").replace(".", "-") + ".sample.json"
        (out_dir / name).write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")
    return errors


def generate_schema_catalog(repo_root: Path) -> list[str]:
    _ = repo_root
    write_catalog_deterministic()
    write_schema_readme_deterministic()
    return []
