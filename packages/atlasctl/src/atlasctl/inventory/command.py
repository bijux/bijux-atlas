from __future__ import annotations

import argparse
import json
from pathlib import Path

from ..core.context import RunContext
from .collectors import (
    collect_budgets,
    collect_commands,
    collect_configs,
    collect_contracts,
    collect_make,
    collect_ops,
    collect_owners,
    collect_schemas,
    collect_touched_paths,
)
from .rendering import outputs_for, render_md, validate_json_schema

DEFAULT_OUT_DIR = Path("docs/_generated")


def _budget_check(repo_root: Path, payload: dict[str, object]) -> list[str]:
    budget_cfg = repo_root / "configs/layout/inventory-budgets.json"
    data = json.loads(budget_cfg.read_text(encoding="utf-8")) if budget_cfg.exists() else {"max": {}}
    maxes = data.get("max", {})
    counts = payload.get("counts", {})
    errs: list[str] = []
    for key, max_v in maxes.items():
        cur = int(counts.get(key, 0))
        if cur > int(max_v):
            errs.append(f"{key} budget exceeded: {cur} > {max_v}")
    return errs


def _emit(repo_root: Path, out_dir: Path, kind: str, payload: dict[str, object], fmt: str, dry_run: bool) -> None:
    json_name, md_name = outputs_for(kind)
    validate_json_schema(repo_root, kind, payload)
    if fmt in {"json", "both"}:
        content = json.dumps(payload, indent=2, sort_keys=True) + "\n"
        if dry_run:
            print(json.dumps(payload, sort_keys=True))
        else:
            (out_dir / json_name).write_text(content, encoding="utf-8")
    if fmt in {"md", "both"}:
        text = render_md(payload)
        if dry_run:
            print(text, end="")
        else:
            (out_dir / md_name).write_text(text, encoding="utf-8")


def run_inventory(
    ctx: RunContext,
    category: str,
    fmt: str,
    out_dir: str | None,
    dry_run: bool,
    check: bool,
    command: str | None = None,
) -> int:
    repo_root = ctx.repo_root
    out = (repo_root / (out_dir or str(DEFAULT_OUT_DIR))).resolve()
    if not dry_run:
        out.mkdir(parents=True, exist_ok=True)

    collectors = {
        "make": collect_make,
        "ops": collect_ops,
        "configs": collect_configs,
        "schemas": collect_schemas,
        "owners": collect_owners,
        "contracts": collect_contracts,
        "budgets": collect_budgets,
        "commands": collect_commands,
    }

    if category == "touched-paths":
        if not command:
            print("inventory touched-paths requires --command")
            return 2
        _emit(repo_root, out, "touched-paths", collect_touched_paths(command), fmt, dry_run)
        return 0

    categories = list(collectors.keys()) if category == "all" else [category]
    for kind in categories:
        payload = collectors[kind](repo_root)
        _emit(repo_root, out, kind, payload, fmt, dry_run)
        if kind == "budgets" and check:
            errs = _budget_check(repo_root, payload)
            if errs:
                for err in errs:
                    print(err)
                return 1

    if not dry_run and category == "all" and fmt in {"md", "both"}:
        (out / "INDEX.md").write_text(
            "\n".join([
                "# Generated Docs Index",
                "",
                "Generated by `make inventory` / `bijux-atlas inventory all`.",
                "",
                "## Files",
                "- `make-targets.md`",
                "- `ops-surface.md`",
                "- `configs-surface.md`",
                "- `schema-index.md`",
                "- `ownership.md`",
                "- `contracts-index.md`",
                "- `inventory-budgets.md`",
                "",
                "## Update",
                "- `make inventory`",
                "- `make verify-inventory`",
            ])
            + "\n",
            encoding="utf-8",
        )

    return 0


def configure_inventory_parser(sub: argparse._SubParsersAction[argparse.ArgumentParser]) -> None:
    parser = sub.add_parser("inventory", help="generate inventory docs and JSON from SSOT")
    parser.add_argument(
        "category",
        choices=[
            "all",
            "make",
            "ops",
            "configs",
            "schemas",
            "owners",
            "contracts",
            "budgets",
            "commands",
            "touched-paths",
        ],
    )
    parser.add_argument("--format", choices=["json", "md", "both"], default="md")
    parser.add_argument("--out-dir", default=str(DEFAULT_OUT_DIR))
    parser.add_argument("--dry-run", action="store_true")
    parser.add_argument("--check", action="store_true", help="enforce budgets for budgets category")
    parser.add_argument("--command", help="command id for touched-paths category")
