from __future__ import annotations

import json
from pathlib import Path


CORE_DOMAINS = ("stack", "k8s", "obs", "load", "e2e", "datasets", "report")


def _list_jsons(root: Path, rel: str) -> list[str]:
    base = root / rel
    if not base.exists():
        return []
    return sorted(p.relative_to(root).as_posix() for p in base.rglob("*.json") if p.is_file())


def _list_schemas(root: Path, domain: str) -> list[str]:
    base = root / "ops" / "schema" / domain
    if not base.exists():
        return []
    return sorted(p.relative_to(root).as_posix() for p in base.rglob("*.schema.json") if p.is_file())


def _domain_index(root: Path, domain: str) -> str:
    prefix = f"ops/{domain}"
    lines = [
        f"# {domain.capitalize()} Index",
        "",
        "Generated by `atlasctl ops gen index`. Do not edit manually.",
        "",
        "## Required Docs",
        "",
    ]
    for name in ("CONTRACT.md", "INDEX.md", "OWNER.md", "README.md"):
        path = root / prefix / name
        marker = "present" if path.exists() else "missing"
        lines.append(f"- `{prefix}/{name}` ({marker})")
    lines += ["", "## Manifests", ""]
    manifests = _list_jsons(root, prefix)
    if manifests:
        lines.extend(f"- `{m}`" for m in manifests if "/suites/" not in m)
    else:
        lines.append("- (none)")
    lines += ["", "## Suites", ""]
    suites = [m for m in manifests if "/suites/" in m]
    if suites:
        lines.extend(f"- `{m}`" for m in suites)
    else:
        lines.append("- (none)")
    lines += ["", "## Schemas", ""]
    schemas = _list_schemas(root, domain)
    if schemas:
        lines.extend(f"- `{s}`" for s in schemas)
    else:
        lines.append("- (none)")
    lines.append("")
    return "\n".join(lines)


def render_indexes(root: Path) -> dict[str, str]:
    outputs: dict[str, str] = {}
    for domain in CORE_DOMAINS:
        outputs[f"ops/{domain}/INDEX.md"] = _domain_index(root, domain)
    # Top-level compiled ops index lives under ops/_generated.
    lines = [
        "# Ops Generated Index",
        "",
        "Generated by `atlasctl ops gen index`. Do not edit manually.",
        "",
        "## Domains",
        "",
    ]
    for domain in CORE_DOMAINS:
        lines.append(f"- `ops/{domain}/INDEX.md`")
    lines += ["", "## Core Metadata", ""]
    for rel in ("ops/inventory/surfaces.json", "configs/ops/public-surface.json", "configs/ops/suites.json"):
        lines.append(f"- `{rel}`")
    lines.append("")
    outputs["ops/_generated/INDEX.md"] = "\n".join(lines)
    return outputs


def write_indexes(root: Path) -> list[str]:
    outputs = render_indexes(root)
    changed: list[str] = []
    for rel, text in sorted(outputs.items()):
        path = root / rel
        path.write_text(text, encoding="utf-8")
        changed.append(rel)
    return changed


def suite_inventory(root: Path) -> dict[str, object]:
    rows: list[dict[str, object]] = []
    for rel in (
        "ops/e2e/suites/suites.json",
        "ops/load/suites/suites.json",
        "ops/obs/suites/suites.json",
        "configs/ops/suites.json",
    ):
        path = root / rel
        if not path.exists():
            continue
        try:
            payload = json.loads(path.read_text(encoding="utf-8"))
        except Exception:
            continue
        if rel == "configs/ops/suites.json":
            suites = payload.get("suites", [])
            for row in suites if isinstance(suites, list) else []:
                if not isinstance(row, dict):
                    continue
                rows.append(
                    {
                        "id": str(row.get("id", "")),
                        "domain": str(row.get("domain", "")),
                        "speed": str(row.get("speed", "")),
                        "markers": row.get("markers", []),
                        "source": rel,
                    }
                )
            continue
        suites = payload.get("suites", [])
        for row in suites if isinstance(suites, list) else []:
            if not isinstance(row, dict):
                continue
            sid = str(row.get("id") or row.get("name") or "")
            domain = rel.split("/")[1]
            rows.append(
                {
                    "id": sid,
                    "domain": domain,
                    "speed": str(row.get("speed", "")),
                    "markers": row.get("markers", []),
                    "source": rel,
                }
            )
    rows.sort(key=lambda r: (str(r["domain"]), str(r["id"]), str(r["source"])))
    return {"schema_version": 1, "kind": "ops-suite-inventory", "total": len(rows), "items": rows}
