from __future__ import annotations

import argparse
import json
import subprocess
from pathlib import Path

from ..core.context import RunContext
from .contracts_check import run_contracts_check
from .explain import LEGACY_TARGET_RE
from .help import render_advanced, render_all, render_gates, render_help, render_list
from .public_targets import entry_map, load_ownership, public_entries, public_names
from .target_graph import parse_make_targets, render_tree


def run_make_command(ctx: RunContext, ns: argparse.Namespace) -> int:
    entries = public_entries()
    if ns.make_cmd == "help":
        if ns.mode == "gates":
            render_gates(entries)
        elif ns.mode == "list":
            render_list(entries)
        elif ns.mode == "advanced":
            render_advanced(entries)
        elif ns.mode == "all":
            render_all()
        else:
            render_help(entries)
        return 0

    if ns.make_cmd == "list":
        render_list(entries)
        return 0

    if ns.make_cmd == "surface":
        payload = _surface_payload()
        if ns.pretty:
            print("Public Make Targets:")
            for row in payload["targets"]:
                print(f"- {row['name']} ({row['owner']}): {row['description']}")
        else:
            print(json.dumps(payload, sort_keys=True))
        return 0

    if ns.make_cmd == "inventory":
        payload = _surface_payload()
        out_dir = Path(ns.out_dir)
        if not out_dir.is_absolute():
            out_dir = (ctx.repo_root / out_dir).resolve()
        out_dir.mkdir(parents=True, exist_ok=True)

        json_path = out_dir / "make-targets.json"
        md_path = out_dir / "make-targets.md"
        json_path.write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")

        lines = [
            "# Make Targets Inventory",
            "",
            "Generated by `atlasctl make inventory`.",
            "",
            "## Public Make Targets",
            "",
        ]
        for row in sorted(payload["targets"], key=lambda r: str(r["name"])):
            lines.append(f"- `{row['name']}` ({row['owner']}): {row['description']}")
        md_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

        if ns.check:
            md_rel = str(md_path.relative_to(ctx.repo_root))
            json_rel = str(json_path.relative_to(ctx.repo_root))
            tracked = subprocess.run(
                ["git", "diff", "--", md_rel, json_rel],
                cwd=ctx.repo_root,
                text=True,
                capture_output=True,
                check=False,
            )
            if tracked.returncode != 0:
                print(tracked.stdout + tracked.stderr)
                return 1

            budget_cfg = ctx.repo_root / "configs/make/public-targets.json"
            if budget_cfg.exists():
                cfg = json.loads(budget_cfg.read_text(encoding="utf-8"))
                max_targets = int(cfg.get("max_public_targets", 20))
                count_targets = len([t for t in payload["targets"] if t.get("name") != "[global]"])
                if count_targets > max_targets:
                    print(
                        json.dumps(
                            {
                                "status": "fail",
                                "reason": "public target budget exceeded",
                                "count": count_targets,
                                "max": max_targets,
                            },
                            sort_keys=True,
                        )
                    )
                    return 1

            docs_path = ctx.repo_root / "docs/development/make-targets.md"
            if docs_path.exists():
                docs_text = docs_path.read_text(encoding="utf-8")
                missing = [
                    str(row["name"])
                    for row in payload["targets"]
                    if row.get("name") != "[global]" and f"- `{row['name']}`" not in docs_text
                ]
                if missing:
                    print(
                        json.dumps(
                            {
                                "status": "fail",
                                "reason": "docs coverage missing for public targets",
                                "missing": sorted(missing),
                            },
                            sort_keys=True,
                        )
                    )
                    return 1

        print(json.dumps({"status": "pass", "json": str(json_path), "md": str(md_path)}, sort_keys=True))
        return 0

    if ns.make_cmd == "explain":
        target = ns.target
        if LEGACY_TARGET_RE.search(target):
            print(f"legacy target names are forbidden: {target}")
            return 2
        entries = entry_map()
        if target not in entries:
            print(f"not public: {target}")
            return 1
        entry = entries[target]
        print(f"target: {target}")
        print(f"description: {entry['description']}")
        print(f"lanes: {', '.join(entry['lanes'])}")
        graph = parse_make_targets(ctx.repo_root / "makefiles")
        print("internal expansion tree:")
        for line in render_tree(graph, target):
            print(f"  {line}")
        return 0

    if ns.make_cmd == "graph":
        target = ns.target
        if target not in set(public_names()):
            print(f"not public: {target}")
            return 1
        graph = parse_make_targets(ctx.repo_root / "makefiles")
        for line in render_tree(graph, target):
            print(line)
        return 0

    if ns.make_cmd == "contracts-check":
        return run_contracts_check(
            ctx,
            fail_fast=ns.fail_fast,
            emit_artifacts=ns.emit_artifacts,
            as_json=ns.json,
        )

    return 2


def configure_make_parser(sub: argparse._SubParsersAction[argparse.ArgumentParser]) -> None:
    p = sub.add_parser("make", help="make target intelligence and contracts checks")
    make_sub = p.add_subparsers(dest="make_cmd", required=True)

    help_p = make_sub.add_parser("help", help="render curated make help output")
    help_p.add_argument("--mode", choices=["help", "gates", "list", "advanced", "all"], default="help")

    make_sub.add_parser("list", help="list curated public make targets")

    explain = make_sub.add_parser("explain", help="explain a public target")
    explain.add_argument("target")

    graph = make_sub.add_parser("graph", help="print public target dependency graph")
    graph.add_argument("target")

    surface = make_sub.add_parser("surface", help="emit public target machine surface")
    surface.add_argument("--pretty", action="store_true", help="render human-readable output")

    inv = make_sub.add_parser("inventory", help="generate make target inventory artifacts")
    inv.add_argument("--out-dir", default="docs/_generated")
    inv.add_argument("--check", action="store_true", help="fail if generated outputs differ")

    cc = make_sub.add_parser("contracts-check", help="run make/gates contract checks")
    cc.add_argument("--json", action="store_true")
    cc.add_argument("--fail-fast", action="store_true")
    cc.add_argument("--emit-artifacts", action="store_true")
