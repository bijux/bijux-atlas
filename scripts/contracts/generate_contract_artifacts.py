#!/usr/bin/env python3
import json
import subprocess
from pathlib import Path

ROOT = Path(__file__).resolve().parents[2]
contracts = ROOT / "docs" / "contracts"
out_gen = ROOT / "docs" / "contracts" / "generated"
out_gen.mkdir(parents=True, exist_ok=True)

error_codes = json.loads((contracts / "ERROR_CODES.json").read_text())["codes"]
metrics = json.loads((contracts / "METRICS.json").read_text())["metrics"]
trace_spans = json.loads((contracts / "TRACE_SPANS.json").read_text())["spans"]
endpoints = json.loads((contracts / "ENDPOINTS.json").read_text())["endpoints"]
chart_keys = json.loads((contracts / "CHART_VALUES.json").read_text())["top_level_keys"]
config_keys = json.loads((contracts / "CONFIG_KEYS.json").read_text())["env_keys"]
artifact_schema = json.loads((contracts / "ARTIFACT_SCHEMA.json").read_text())
policy_schema = json.loads((contracts / "POLICY_SCHEMA.json").read_text())

# rust generated core error-code enum + constants
core_generated_dir = ROOT / "crates" / "bijux-atlas-core" / "src" / "generated"
core_generated_dir.mkdir(parents=True, exist_ok=True)
(core_generated_dir / "mod.rs").write_text("pub mod error_codes;\n")

core_rust_path = core_generated_dir / "error_codes.rs"
core_rust = [
    "// @generated by scripts/contracts/generate_contract_artifacts.py",
    "use serde::{Deserialize, Serialize};",
    "",
    "#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]",
    "#[non_exhaustive]",
    "pub enum ErrorCode {",
]
for code in error_codes:
    core_rust.append(f"    {code},")
core_rust.extend(
    [
        "}",
        "",
        "impl ErrorCode {",
        "    #[must_use]",
        "    pub const fn as_str(self) -> &'static str {",
        "        match self {",
    ]
)
for code in error_codes:
    core_rust.append(f'            Self::{code} => "{code}",')
core_rust.extend(
    [
        "        }",
        "    }",
        "",
        "    pub fn parse(value: &str) -> Option<Self> {",
        "        match value {",
    ]
)
for code in error_codes:
    core_rust.append(f'            "{code}" => Some(Self::{code}),')
core_rust.extend(
    [
        "            _ => None,",
        "        }",
        "    }",
        "}",
        "",
        "#[allow(dead_code)]",
        "pub const ERROR_CODES: &[&str] = &[",
    ]
)
for code in error_codes:
    core_rust.append(f'    "{code}",')
core_rust.append("];\n")
core_rust_path.write_text("\n".join(core_rust))

# rust generated API constants
rust_path = ROOT / "crates" / "bijux-atlas-api" / "src" / "generated" / "error_codes.rs"
rust_path.parent.mkdir(parents=True, exist_ok=True)
rust = [
    "// @generated by scripts/contracts/generate_contract_artifacts.py",
    "pub const API_ERROR_CODES: &[&str] = &[",
]
for code in error_codes:
    rust.append(f'    "{code}",')
rust.extend(
    [
        "];",
        "",
        "#[allow(dead_code)]",
        "pub type ApiErrorCode = bijux_atlas_core::ErrorCode;",
        "",
        "#[allow(dead_code)]",
        "pub fn parse_error_code(value: &str) -> Option<ApiErrorCode> {",
        "    ApiErrorCode::parse(value)",
        "}",
        "",
    ]
)
rust_path.write_text("\n".join(rust))

# rust generated metrics + trace span constants
server_gen_dir = ROOT / "crates" / "bijux-atlas-server" / "src" / "telemetry" / "generated"
server_gen_dir.mkdir(parents=True, exist_ok=True)
(server_gen_dir / "mod.rs").write_text(
    "// @generated by scripts/contracts/generate_contract_artifacts.py\n"
    "pub mod metrics_contract;\n"
    "pub mod trace_spans_contract;\n"
)

metrics_rs = [
    "// @generated by scripts/contracts/generate_contract_artifacts.py",
    "#[allow(dead_code)]",
    "pub const CONTRACT_METRIC_NAMES: &[&str] = &[",
]
for metric in metrics:
    metrics_rs.append(f'    "{metric["name"]}",')
metrics_rs.append("];")
metrics_rs.append("")
metrics_rs.append("#[allow(dead_code)]")
metrics_rs.append("pub const CONTRACT_METRIC_LABELS: &[(&str, &[&str])] = &[")
for metric in metrics:
    metrics_rs.append("    (")
    metrics_rs.append(f'        "{metric["name"]}",')
    labels = ", ".join(f'"{x}"' for x in metric["labels"])
    metrics_rs.append(f"        &[{labels}],")
    metrics_rs.append("    ),")
metrics_rs.append("];\n")
(server_gen_dir / "metrics_contract.rs").write_text("\n".join(metrics_rs))

spans_rs = [
    "// @generated by scripts/contracts/generate_contract_artifacts.py",
    "#[allow(dead_code)]",
    "pub const CONTRACT_TRACE_SPAN_NAMES: &[&str] = &[",
]
for span in trace_spans:
    spans_rs.append(f'    "{span["name"]}",')
spans_rs.append("];")
spans_rs.append("")
spans_rs.append("#[allow(dead_code)]")
spans_rs.append("pub const CONTRACT_TRACE_SPAN_ATTRIBUTES: &[(&str, &[&str])] = &[")
for span in trace_spans:
    spans_rs.append("    (")
    spans_rs.append(f'        "{span["name"]}",')
    attrs = ", ".join(f'"{x}"' for x in span["required_attributes"])
    spans_rs.append(f"        &[{attrs}],")
    spans_rs.append("    ),")
spans_rs.append("];\n")
(server_gen_dir / "trace_spans_contract.rs").write_text("\n".join(spans_rs))

for rust_file in (
    core_generated_dir / "mod.rs",
    core_rust_path,
    rust_path,
    server_gen_dir / "mod.rs",
    server_gen_dir / "metrics_contract.rs",
    server_gen_dir / "trace_spans_contract.rs",
):
    subprocess.run(["rustfmt", str(rust_file)], check=True)

# markdown artifacts
(out_gen / "ERROR_CODES.md").write_text(
    "# Error Codes (Generated)\n\n" + "\n".join(f"- `{c}`" for c in error_codes) + "\n"
)
(out_gen / "METRICS.md").write_text(
    "# Metrics (Generated)\n\n"
    + "\n".join(
        f"- `{m['name']}` labels: {', '.join(m['labels'])}" for m in metrics
    )
    + "\n"
)
(out_gen / "ENDPOINTS.md").write_text(
    "# Endpoints (Generated)\n\n"
    + "\n".join(
        f"- `{e['method']} {e['path']}` telemetry: `{e['telemetry_class']}`"
        for e in endpoints
    )
    + "\n"
)
(out_gen / "CHART_VALUES.md").write_text(
    "# Chart Values Keys (Generated)\n\n"
    + "\n".join(f"- `{k}`" for k in chart_keys)
    + "\n"
)
(out_gen / "TRACE_SPANS.md").write_text(
    "# Trace Spans (Generated)\n\n"
    + "\n".join(
        f"- `{s['name']}` attrs: {', '.join(s['required_attributes'])}" for s in trace_spans
    )
    + "\n"
)
(out_gen / "CONFIG_KEYS.md").write_text(
    "# Config Keys (Generated)\n\n"
    + "\n".join(f"- `{k}`" for k in config_keys)
    + "\n"
)
(out_gen / "ARTIFACT_SCHEMA.md").write_text(
    "# Artifact Schema (Generated)\n\n```json\n"
    + json.dumps(artifact_schema, indent=2, sort_keys=True)
    + "\n```\n"
)
(out_gen / "POLICY_SCHEMA.md").write_text(
    "# Policy Schema (Generated)\n\n```json\n"
    + json.dumps(policy_schema, indent=2, sort_keys=True)
    + "\n```\n"
)

# generated compatibility artifact for observability gate
obs_metrics_path = ROOT / "observability" / "metrics_contract.json"
obs_payload = {
    "schema_version": 1,
    "required_metrics": {m["name"]: m["labels"] for m in metrics},
    "required_spans": [s["name"] for s in trace_spans],
    "required_log_fields": ["request_id", "dataset"],
    "allowed_dynamic_labels": ["route", "status", "query_type", "stage", "code"],
}
obs_metrics_path.write_text(json.dumps(obs_payload, indent=2, sort_keys=True) + "\n")

print("contract artifacts generated")
