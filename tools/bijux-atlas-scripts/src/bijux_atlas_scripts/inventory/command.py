from __future__ import annotations

import argparse
import json
from pathlib import Path

from ..core.context import RunContext

DEFAULT_OUT_DIR = Path("docs/_generated")


def _repo_files(repo_root: Path, pattern: str) -> list[str]:
    return sorted(str(p.relative_to(repo_root)) for p in repo_root.glob(pattern) if p.is_file())


def collect_make(repo_root: Path) -> dict[str, object]:
    data = json.loads((repo_root / "configs/make/public-targets.json").read_text(encoding="utf-8"))
    targets = data.get("public_targets", [])
    return {
        "kind": "make",
        "targets": [
            {
                "name": t.get("name"),
                "description": t.get("description", ""),
                "area": t.get("area", ""),
                "lanes": t.get("lanes", []),
            }
            for t in targets
            if isinstance(t, dict)
        ],
    }


def collect_ops(repo_root: Path) -> dict[str, object]:
    data = json.loads((repo_root / "configs/ops/public-surface.json").read_text(encoding="utf-8"))
    return {
        "kind": "ops",
        "make_targets": sorted(data.get("make_targets", [])),
        "ops_run_commands": sorted(data.get("ops_run_commands", [])),
        "core_targets": sorted(data.get("core_targets", [])),
    }


def collect_configs(repo_root: Path) -> dict[str, object]:
    files = []
    for p in sorted((repo_root / "configs").rglob("*")):
        if p.is_file() and p.suffix in {".json", ".yaml", ".yml", ".toml", ".md", ".txt"}:
            files.append(str(p.relative_to(repo_root)))
    return {"kind": "configs", "files": files}


def collect_schemas(repo_root: Path) -> dict[str, object]:
    schemas = _repo_files(repo_root, "configs/_schemas/**/*.json") + _repo_files(repo_root, "ops/_schemas/**/*.json")
    return {"kind": "schemas", "files": sorted(set(schemas))}


def collect_owners(repo_root: Path) -> dict[str, object]:
    owners: dict[str, dict[str, object]] = {}
    for rel in ("configs/meta/ownership.json", "configs/_meta/ownership.json", "makefiles/ownership.json"):
        p = repo_root / rel
        if not p.exists():
            continue
        payload = json.loads(p.read_text(encoding="utf-8"))
        if isinstance(payload, dict):
            owners[rel] = payload
    return {"kind": "owners", "sources": owners}


def collect_contracts(repo_root: Path) -> dict[str, object]:
    contracts = sorted(str(p.relative_to(repo_root)) for p in repo_root.rglob("CONTRACT.md") if p.is_file())
    schemas = sorted(
        set(
            _repo_files(repo_root, "configs/contracts/*.schema.json")
            + _repo_files(repo_root, "ops/_schemas/**/*.schema.json")
        )
    )
    return {"kind": "contracts", "contract_files": contracts, "schema_files": schemas}


def collect_budgets(repo_root: Path) -> dict[str, object]:
    make_targets = collect_make(repo_root)["targets"]
    scripts_commands = [p.name for p in (repo_root / "scripts/bin").glob("*") if p.is_file()]
    ops_areas = [p.name for p in (repo_root / "ops").iterdir() if p.is_dir() and not p.name.startswith("_")]
    counts = {
        "public_make_targets": len(make_targets),
        "scripts_commands": len(scripts_commands),
        "ops_areas": len(ops_areas),
    }
    return {
        "kind": "budgets",
        "counts": counts,
        "scripts_commands": sorted(scripts_commands),
        "ops_areas": sorted(ops_areas),
    }


def render_md(payload: dict[str, object]) -> str:
    kind = str(payload["kind"])
    lines = [f"# {kind.title()} Inventory", "", "Generated by `bijux-atlas-scripts inventory`.", ""]
    if kind == "make":
        lines += ["| Target | Area | Description |", "|---|---|---|"]
        for row in payload.get("targets", []):
            lines.append(f"| `{row['name']}` | `{row['area']}` | {row['description']} |")
    elif kind == "ops":
        lines.append("## Make Targets")
        lines.append("")
        for t in payload.get("make_targets", []):
            lines.append(f"- `{t}`")
        lines.append("")
        lines.append("## Run Commands")
        lines.append("")
        for t in payload.get("ops_run_commands", []):
            lines.append(f"- `{t}`")
    elif kind in {"configs", "schemas"}:
        for f in payload.get("files", []):
            lines.append(f"- `{f}`")
    elif kind == "owners":
        for src, data in payload.get("sources", {}).items():
            lines.append(f"## `{src}`")
            lines.append("")
            lines.append(f"- entries: `{len(data)}`")
            lines.append("")
    elif kind == "contracts":
        lines.append("## CONTRACT.md")
        lines.append("")
        for f in payload.get("contract_files", []):
            lines.append(f"- `{f}`")
        lines.append("")
        lines.append("## Schemas")
        lines.append("")
        for f in payload.get("schema_files", []):
            lines.append(f"- `{f}`")
    elif kind == "budgets":
        counts = payload.get("counts", {})
        for k, v in counts.items():
            lines.append(f"- `{k}`: `{v}`")
    return "\n".join(lines) + "\n"


def outputs_for(kind: str) -> tuple[Path, Path]:
    mapping = {
        "make": (Path("make-targets.json"), Path("make-targets.md")),
        "ops": (Path("ops-surface.json"), Path("ops-surface.md")),
        "configs": (Path("configs-surface.json"), Path("configs-surface.md")),
        "schemas": (Path("schema-index.json"), Path("schema-index.md")),
        "owners": (Path("ownership.json"), Path("ownership.md")),
        "contracts": (Path("contracts-index.json"), Path("contracts-index.md")),
        "budgets": (Path("inventory-budgets.json"), Path("inventory-budgets.md")),
    }
    return mapping[kind]


def validate_json_schema(repo_root: Path, kind: str, payload: dict[str, object]) -> None:
    import jsonschema

    schema = json.loads((repo_root / f"configs/contracts/inventory-{kind}.schema.json").read_text(encoding="utf-8"))
    jsonschema.validate(payload, schema)


def _budget_check(repo_root: Path, payload: dict[str, object]) -> list[str]:
    budget_cfg = repo_root / "configs/layout/inventory-budgets.json"
    data = json.loads(budget_cfg.read_text(encoding="utf-8")) if budget_cfg.exists() else {"max": {}}
    maxes = data.get("max", {})
    counts = payload.get("counts", {})
    errs: list[str] = []
    for key, max_v in maxes.items():
        cur = int(counts.get(key, 0))
        if cur > int(max_v):
            errs.append(f"{key} budget exceeded: {cur} > {max_v}")
    return errs


def _emit(repo_root: Path, out_dir: Path, kind: str, payload: dict[str, object], fmt: str, dry_run: bool) -> None:
    json_name, md_name = outputs_for(kind)
    validate_json_schema(repo_root, kind, payload)
    if fmt in {"json", "both"}:
        if dry_run:
            print(json.dumps(payload, sort_keys=True))
        else:
            (out_dir / json_name).write_text(json.dumps(payload, indent=2, sort_keys=True) + "\n", encoding="utf-8")
    if fmt in {"md", "both"}:
        text = render_md(payload)
        if dry_run:
            print(text, end="")
        else:
            (out_dir / md_name).write_text(text, encoding="utf-8")


def run_inventory(ctx: RunContext, category: str, fmt: str, out_dir: str | None, dry_run: bool, check: bool) -> int:
    repo_root = ctx.repo_root
    out = (repo_root / (out_dir or str(DEFAULT_OUT_DIR))).resolve()
    if not dry_run:
        out.mkdir(parents=True, exist_ok=True)

    collectors = {
        "make": collect_make,
        "ops": collect_ops,
        "configs": collect_configs,
        "schemas": collect_schemas,
        "owners": collect_owners,
        "contracts": collect_contracts,
        "budgets": collect_budgets,
    }

    categories = list(collectors.keys()) if category == "all" else [category]
    for kind in categories:
        payload = collectors[kind](repo_root)
        _emit(repo_root, out, kind, payload, fmt, dry_run)
        if kind == "budgets" and check:
            errs = _budget_check(repo_root, payload)
            if errs:
                for e in errs:
                    print(e)
                return 1

    if not dry_run and category == "all" and fmt in {"md", "both"}:
        index = out / "INDEX.md"
        index.write_text(
            "\n".join(
                [
                    "# Generated Docs Index",
                    "",
                    "Generated by `make inventory` / `bijux-atlas-scripts inventory all`.",
                    "",
                    "## Files",
                    "- `make-targets.md`",
                    "- `ops-surface.md`",
                    "- `configs-surface.md`",
                    "- `schema-index.md`",
                    "- `ownership.md`",
                    "- `contracts-index.md`",
                    "- `inventory-budgets.md`",
                    "",
                    "## Update",
                    "- `make inventory`",
                    "- `make verify-inventory`",
                ]
            )
            + "\n",
            encoding="utf-8",
        )

    return 0


def configure_inventory_parser(sub: argparse._SubParsersAction[argparse.ArgumentParser]) -> None:
    p = sub.add_parser("inventory", help="generate inventory docs and JSON from SSOT")
    p.add_argument(
        "category",
        choices=["all", "make", "ops", "configs", "schemas", "owners", "contracts", "budgets"],
    )
    p.add_argument("--format", choices=["json", "md", "both"], default="md")
    p.add_argument("--out-dir", default=str(DEFAULT_OUT_DIR))
    p.add_argument("--dry-run", action="store_true")
    p.add_argument("--check", action="store_true", help="enforce budgets for budgets category")
