// SPDX-License-Identifier: Apache-2.0

fn datasets_contracts() -> Vec<Contract> {
    vec![
        Contract { id: ContractId("OPS-DATASETS-001".to_string()), title: "datasets manifest lock contract", tests: vec![TestCase { id: TestId("ops.datasets.manifest_and_lock_consistent".to_string()), title: "dataset manifest and lock ids are consistent", kind: TestKind::Pure, run: test_ops_dataset_001_manifest_and_lock, }] },
        Contract { id: ContractId("OPS-DATASETS-002".to_string()), title: "datasets fixture inventory contract", tests: vec![TestCase { id: TestId("ops.datasets.fixture_inventory_matches_disk".to_string()), title: "fixture inventory matches fixture directories and references", kind: TestKind::Pure, run: test_ops_dataset_002_fixture_inventory_matches_disk, }] },
        Contract { id: ContractId("OPS-DATASETS-003".to_string()), title: "datasets fixture drift promotion contract", tests: vec![TestCase { id: TestId("ops.datasets.no_fixture_drift_without_promotion_record".to_string()), title: "fixture drift requires explicit promotion rule coverage", kind: TestKind::Pure, run: test_ops_dataset_003_no_fixture_drift_without_promotion_record, }] },
        Contract { id: ContractId("OPS-DATASETS-004".to_string()), title: "datasets release diff determinism contract", tests: vec![TestCase { id: TestId("ops.datasets.release_diff_fixtures_deterministic".to_string()), title: "release-diff fixture lock and golden payloads are deterministic", kind: TestKind::Pure, run: test_ops_dataset_004_release_diff_fixtures_are_deterministic, }] },
        Contract { id: ContractId("OPS-DATASETS-005".to_string()), title: "datasets qc metadata summary contract", tests: vec![TestCase { id: TestId("ops.datasets.qc_metadata_and_golden_valid".to_string()), title: "qc metadata and summary golden are parseable and linked", kind: TestKind::Pure, run: test_ops_datasets_005_qc_metadata_and_golden_valid, }] },
        Contract { id: ContractId("OPS-DATASETS-006".to_string()), title: "datasets rollback policy contract", tests: vec![TestCase { id: TestId("ops.datasets.rollback_policy_exists_valid".to_string()), title: "rollback policy exists and includes required rollback structure", kind: TestKind::Pure, run: test_ops_datasets_006_rollback_policy_exists_valid, }] },
        Contract { id: ContractId("OPS-DATASETS-007".to_string()), title: "datasets promotion rules contract", tests: vec![TestCase { id: TestId("ops.datasets.promotion_rules_exists_valid".to_string()), title: "promotion rules exist with canonical environment coverage and pin references", kind: TestKind::Pure, run: test_ops_datasets_007_promotion_rules_exists_valid, }] },
        Contract { id: ContractId("OPS-DATASETS-008".to_string()), title: "datasets consumer interface contract", tests: vec![TestCase { id: TestId("ops.datasets.consumer_list_consistent_with_runtime_queries".to_string()), title: "consumer list interfaces resolve to runnable repository paths", kind: TestKind::Pure, run: test_ops_datasets_008_consumer_list_consistent_with_runtime_queries, }] },
        Contract { id: ContractId("OPS-DATASETS-009".to_string()), title: "datasets freeze policy contract", tests: vec![TestCase { id: TestId("ops.datasets.freeze_policy_exists_enforced".to_string()), title: "freeze policy enforces append-only fixture immutability", kind: TestKind::Pure, run: test_ops_datasets_009_freeze_policy_exists_enforced, }] },
        Contract { id: ContractId("OPS-DATASETS-010".to_string()), title: "datasets store layout contract", tests: vec![TestCase { id: TestId("ops.datasets.dataset_store_layout_contract_enforced".to_string()), title: "dataset ids and fixture paths follow canonical store layout", kind: TestKind::Pure, run: test_ops_datasets_010_dataset_store_layout_contract_enforced, }] },
    ]
}
