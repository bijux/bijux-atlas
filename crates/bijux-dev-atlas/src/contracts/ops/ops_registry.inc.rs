pub fn contracts(repo_root: &Path) -> Result<Vec<Contract>, String> {
    let rows = vec![
        Contract {
            id: ContractId("OPS-000".to_string()),
            title: "ops directory contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.dir.allowed_root_files".to_string()),
                    title: "ops root allows only contract/readme root files",
                    kind: TestKind::Pure,
                    run: test_ops_000_allowed_root_files,
                },
                TestCase {
                    id: TestId("ops.dir.forbid_extra_markdown_root".to_string()),
                    title: "ops root forbids extra markdown",
                    kind: TestKind::Pure,
                    run: test_ops_000_forbid_extra_markdown_root,
                },
                TestCase {
                    id: TestId("ops.dir.allow_only_known_domain_dirs".to_string()),
                    title: "ops root allows only canonical domain directories",
                    kind: TestKind::Pure,
                    run: test_ops_000_allow_only_known_domain_dirs,
                },
                TestCase {
                    id: TestId("ops.dir.forbid_extra_markdown_recursive".to_string()),
                    title: "ops forbids recursive markdown outside approved surface",
                    kind: TestKind::Pure,
                    run: test_ops_000_forbid_extra_markdown_recursive,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-001".to_string()),
            title: "ops generated lifecycle contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.generated.runtime.allowed_files".to_string()),
                    title: "ops/_generated allows only runtime artifact formats",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_runtime_allowed_files,
                },
                TestCase {
                    id: TestId("ops.generated.example.allowed_files".to_string()),
                    title: "ops/_generated.example allows only committed artifact formats",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_example_allowed_files,
                },
                TestCase {
                    id: TestId("ops.generated.runtime.no_example_files".to_string()),
                    title: "ops/_generated forbids example artifacts",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_runtime_forbid_example_files,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-002".to_string()),
            title: "ops required domain files contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.domain.required_contract_and_readme".to_string()),
                    title: "each ops domain includes README.md and CONTRACT.md",
                    kind: TestKind::Pure,
                    run: test_ops_002_domain_required_files,
                },
                TestCase {
                    id: TestId("ops.domain.forbid_legacy_docs".to_string()),
                    title: "legacy domain INDEX/OWNER/REQUIRED markdown files are forbidden",
                    kind: TestKind::Pure,
                    run: test_ops_002_forbid_legacy_domain_docs,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-003".to_string()),
            title: "ops markdown budget contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.markdown_budget.readme".to_string()),
                    title: "README markdown files stay within line budget",
                    kind: TestKind::Pure,
                    run: test_ops_003_readme_markdown_budget,
                },
                TestCase {
                    id: TestId("ops.markdown_budget.contract".to_string()),
                    title: "CONTRACT markdown files stay within line budget",
                    kind: TestKind::Pure,
                    run: test_ops_003_contract_markdown_budget,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-004".to_string()),
            title: "ops docs ssot boundary contract",
            tests: vec![TestCase {
                id: TestId("ops.docs.readme_ssot_boundary".to_string()),
                title: "ops root readme remains navigation-only and references docs/operations",
                kind: TestKind::Pure,
                run: test_ops_004_readme_ssot_boundary,
            }],
        },
        Contract {
            id: ContractId("OPS-005".to_string()),
            title: "ops contract document generation contract",
            tests: vec![TestCase {
                id: TestId("ops.contract_doc.generated_match".to_string()),
                title: "ops CONTRACT.md matches generated output from contract registry",
                kind: TestKind::Pure,
                run: test_ops_contract_doc_generated_match,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-001".to_string()),
            title: "ops root allowed surface contract",
            tests: vec![TestCase {
                id: TestId("ops.root.allowed_surface".to_string()),
                title: "ops root contains only canonical files and domain directories",
                kind: TestKind::Pure,
                run: test_ops_root_001_allowed_surface,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-002".to_string()),
            title: "ops root markdown contract",
            tests: vec![TestCase {
                id: TestId("ops.root.forbid_extra_markdown".to_string()),
                title: "ops root forbids markdown files other than README.md and CONTRACT.md",
                kind: TestKind::Pure,
                run: test_ops_root_002_forbid_extra_root_markdown,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-003".to_string()),
            title: "ops no shell scripts contract",
            tests: vec![TestCase {
                id: TestId("ops.root.no_shell_script_files".to_string()),
                title: "ops tree contains no shell script files or bash shebangs",
                kind: TestKind::Pure,
                run: test_ops_root_003_no_shell_script_files,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-004".to_string()),
            title: "ops max directory depth contract",
            tests: vec![TestCase {
                id: TestId("ops.root.max_directory_depth".to_string()),
                title: "ops file paths remain within configured depth budget",
                kind: TestKind::Pure,
                run: test_ops_root_004_max_directory_depth,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-005".to_string()),
            title: "ops filename policy contract",
            tests: vec![TestCase {
                id: TestId("ops.root.filename_policy".to_string()),
                title: "ops filenames follow stable lowercase policy with explicit allowlist exceptions",
                kind: TestKind::Pure,
                run: test_ops_root_005_filename_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-006".to_string()),
            title: "ops generated gitignore policy contract",
            tests: vec![TestCase {
                id: TestId("ops.root.generated_gitignore_policy".to_string()),
                title: "ops/_generated is gitignored with explicit .gitkeep exception",
                kind: TestKind::Pure,
                run: test_ops_root_006_generated_gitignore_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-007".to_string()),
            title: "ops generated example secret guard contract",
            tests: vec![TestCase {
                id: TestId("ops.root.generated_example_secret_guard".to_string()),
                title: "ops/_generated.example is secret-free and json payloads are parseable",
                kind: TestKind::Pure,
                run: test_ops_root_007_generated_example_secret_guard,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-008".to_string()),
            title: "ops placeholder directory contract",
            tests: vec![TestCase {
                id: TestId("ops.root.placeholder_dirs_allowlist".to_string()),
                title: "ops placeholder directories are explicitly allowlisted",
                kind: TestKind::Pure,
                run: test_ops_root_008_placeholder_dirs_allowlist,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-009".to_string()),
            title: "ops policy inventory coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.root.policy_files_inventory_coverage".to_string()),
                title: "ops policy/config files are covered by inventory sources",
                kind: TestKind::Pure,
                run: test_ops_root_009_inventory_coverage_for_policy_files,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-010".to_string()),
            title: "ops deleted doc name guard contract",
            tests: vec![TestCase {
                id: TestId("ops.root.forbid_deleted_doc_names".to_string()),
                title: "forbidden legacy ops markdown names must not be reintroduced",
                kind: TestKind::Pure,
                run: test_ops_root_010_forbid_deleted_doc_names,
            }],
        },
        Contract {
            id: ContractId("OPS-DOCS-001".to_string()),
            title: "operations docs policy linkage contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.docs.policy_keyword_requires_contract_id".to_string()),
                    title: "operations docs with policy keywords must reference OPS contract ids",
                    kind: TestKind::Pure,
                    run: test_ops_docs_001_policy_keyword_requires_contract_id,
                },
                TestCase {
                    id: TestId("ops.docs.index_crosslinks_contracts".to_string()),
                    title: "operations index must state docs/contracts boundary and include OPS references",
                    kind: TestKind::Pure,
                    run: test_ops_docs_002_index_crosslinks_contracts,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-INV-001".to_string()),
            title: "inventory completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.completeness".to_string()),
                title: "inventory registers all domains and policy files",
                kind: TestKind::Pure,
                run: test_ops_inv_001_inventory_completeness,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-002".to_string()),
            title: "inventory orphan files contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.no_orphan_files".to_string()),
                title: "ops files must be mapped through inventory sources",
                kind: TestKind::Pure,
                run: test_ops_inv_002_no_orphan_files,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-003".to_string()),
            title: "inventory duplicate source contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.no_duplicate_ssot_sources".to_string()),
                title: "duplicate ssot markdown sources are forbidden",
                kind: TestKind::Pure,
                run: test_ops_inv_003_no_duplicate_ssot,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-004".to_string()),
            title: "inventory authority tier contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.authority_tiers_enforced".to_string()),
                title: "authority tier exceptions are structured and expiry-bound",
                kind: TestKind::Pure,
                run: test_ops_inv_004_authority_tiers_enforced,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-005".to_string()),
            title: "inventory control graph contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.control_graph_validated".to_string()),
                title: "control graph edges and node mappings are valid and acyclic",
                kind: TestKind::Pure,
                run: test_ops_inv_005_control_graph_validated,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-006".to_string()),
            title: "inventory contract id format contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_id_format".to_string()),
                title: "all ops contract ids follow OPS-<PILLAR>-NNN format",
                kind: TestKind::Pure,
                run: test_ops_inv_006_contract_id_format,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-007".to_string()),
            title: "inventory gates registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.gates_registry_mapped".to_string()),
                title: "gates registry exists and maps each gate to one action id",
                kind: TestKind::Pure,
                run: test_ops_inv_007_gates_registry_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-008".to_string()),
            title: "inventory drills registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.drills_registry_mapped".to_string()),
                title: "drills registry ids map to runnable observe drill definitions",
                kind: TestKind::Pure,
                run: test_ops_inv_008_drills_registry_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-009".to_string()),
            title: "inventory owners registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.owners_registry_complete".to_string()),
                title: "owners registry exists and includes all ops domain directories",
                kind: TestKind::Pure,
                run: test_ops_inv_009_owners_registry_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-010".to_string()),
            title: "inventory schema coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.schema_coverage".to_string()),
                title: "inventory schema directory includes required registry schemas",
                kind: TestKind::Pure,
                run: test_ops_inv_010_inventory_schema_coverage,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-001".to_string()),
            title: "inventory contract gate map coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.every_contract_mapped".to_string()),
                title: "every contract id is mapped in contract-gate-map",
                kind: TestKind::Pure,
                run: test_ops_inv_map_001_every_contract_id_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-002".to_string()),
            title: "inventory contract gate map gate reference contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.mapped_gates_exist".to_string()),
                title: "every mapped gate id exists in gates registry",
                kind: TestKind::Pure,
                run: test_ops_inv_map_002_mapped_gates_exist,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-003".to_string()),
            title: "inventory contract gate map command surface contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.mapped_commands_registered".to_string()),
                title: "every mapped command is registered in ops command surface",
                kind: TestKind::Pure,
                run: test_ops_inv_map_003_mapped_commands_registered,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-004".to_string()),
            title: "inventory contract gate map effects annotation contract",
            tests: vec![TestCase {
                id: TestId(
                    "ops.inventory.contract_gate_map.effects_annotation_matches_mode".to_string(),
                ),
                title: "effects annotations match contract test kinds and execution mode",
                kind: TestKind::Pure,
                run: test_ops_inv_map_004_effects_annotation_matches_contract_mode,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-005".to_string()),
            title: "inventory contract gate map orphan gate contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.no_orphan_gates".to_string()),
                title: "every gate id is referenced by at least one contract mapping",
                kind: TestKind::Pure,
                run: test_ops_inv_map_005_no_orphan_gates,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-006".to_string()),
            title: "inventory contract gate map orphan contract contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.no_orphan_contracts".to_string()),
                title: "every contract maps to gate ids or is explicitly static-only",
                kind: TestKind::Pure,
                run: test_ops_inv_map_006_no_orphan_contracts,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-007".to_string()),
            title: "inventory contract gate map static purity contract",
            tests: vec![TestCase {
                id: TestId(
                    "ops.inventory.contract_gate_map.static_only_contracts_are_pure".to_string(),
                ),
                title: "static-only mappings are restricted to pure test contracts",
                kind: TestKind::Pure,
                run: test_ops_inv_map_007_static_only_contracts_are_pure,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-008".to_string()),
            title: "inventory contract gate map effect kind contract",
            tests: vec![TestCase {
                id: TestId(
                    "ops.inventory.contract_gate_map.effect_contracts_require_effect_kind"
                        .to_string(),
                ),
                title: "effect mappings require subprocess or network test kinds and annotations",
                kind: TestKind::Pure,
                run: test_ops_inv_map_008_effect_contracts_require_effect_kind,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-009".to_string()),
            title: "inventory contract gate map explain coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.explain_shows_mapped_gates".to_string()),
                title: "contract explain source mappings expose gate ids for non-static contracts",
                kind: TestKind::Pure,
                run: test_ops_inv_map_009_explain_shows_mapped_gates,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-MAP-010".to_string()),
            title: "inventory contract gate map canonical order contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_gate_map.mapping_sorted_canonical".to_string()),
                title: "contract-gate-map is sorted by contract id and canonical json",
                kind: TestKind::Pure,
                run: test_ops_inv_map_010_mapping_sorted_canonical,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-001".to_string()),
            title: "ops root command surface required commands contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.required_commands_exist".to_string()),
                title: "required ops command verbs exist in command surface registry",
                kind: TestKind::Pure,
                run: test_ops_root_surface_001_required_commands_exist,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-002".to_string()),
            title: "ops root command surface no hidden commands contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.no_hidden_commands".to_string()),
                title: "listed commands and action dispatch entries must match exactly",
                kind: TestKind::Pure,
                run: test_ops_root_surface_002_no_hidden_commands,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-003".to_string()),
            title: "ops root command surface deterministic ordering contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.surface_ordering_deterministic".to_string()),
                title: "command surface list is sorted deterministically",
                kind: TestKind::Pure,
                run: test_ops_root_surface_003_surface_ordering_deterministic,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-004".to_string()),
            title: "ops root command surface effects declaration contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.commands_declare_effects".to_string()),
                title: "mapped commands declare effects_required annotations",
                kind: TestKind::Pure,
                run: test_ops_root_surface_004_commands_declare_effects,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-005".to_string()),
            title: "ops root command surface pillar grouping contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.commands_grouped_by_pillar".to_string()),
                title: "ops command actions use approved pillar-style domain groups",
                kind: TestKind::Pure,
                run: test_ops_root_surface_005_commands_grouped_by_pillar,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-006".to_string()),
            title: "ops root command surface ad-hoc group guard contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.forbid_adhoc_command_groups".to_string()),
                title: "ops command actions must not use ad-hoc misc/util group names",
                kind: TestKind::Pure,
                run: test_ops_root_surface_006_forbid_adhoc_command_groups,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-007".to_string()),
            title: "ops root command surface purpose contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.command_purpose_defined".to_string()),
                title: "each command action defines a stable purpose string",
                kind: TestKind::Pure,
                run: test_ops_root_surface_007_command_purpose_defined,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-008".to_string()),
            title: "ops root command surface json output contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.command_supports_json".to_string()),
                title: "each command action declares json output support",
                kind: TestKind::Pure,
                run: test_ops_root_surface_008_command_supports_json,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-009".to_string()),
            title: "ops root command surface dry-run policy contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.command_dry_run_policy".to_string()),
                title: "each command action declares dry-run policy where applicable",
                kind: TestKind::Pure,
                run: test_ops_root_surface_009_command_dry_run_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-SURFACE-010".to_string()),
            title: "ops root command surface artifacts policy contract",
            tests: vec![TestCase {
                id: TestId("ops.root_surface.artifacts_root_policy".to_string()),
                title: "each command action declares artifacts root write policy",
                kind: TestKind::Pure,
                run: test_ops_root_surface_010_artifacts_root_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-011".to_string()),
            title: "ops markdown allowlist contract",
            tests: vec![TestCase {
                id: TestId("ops.root.markdown_allowlist_only".to_string()),
                title: "ops markdown files are restricted to explicit allowlist paths",
                kind: TestKind::Pure,
                run: test_ops_root_011_markdown_allowlist_only,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-012".to_string()),
            title: "ops pillar readme cardinality contract",
            tests: vec![TestCase {
                id: TestId("ops.root.single_readme_per_pillar".to_string()),
                title: "each non-root pillar has exactly one README.md at pillar root",
                kind: TestKind::Pure,
                run: test_ops_root_012_single_readme_per_pillar,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-013".to_string()),
            title: "ops markdown allowlist inventory contract",
            tests: vec![TestCase {
                id: TestId("ops.root.markdown_allowlist_file_valid".to_string()),
                title: "markdown allowlist inventory file exists and is non-empty",
                kind: TestKind::Pure,
                run: test_ops_root_013_markdown_allowlist_file_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-014".to_string()),
            title: "ops procedure text contract",
            tests: vec![TestCase {
                id: TestId("ops.root.no_procedure_docs_in_ops".to_string()),
                title: "procedure-like language in ops markdown requires OPS contract references",
                kind: TestKind::Pure,
                run: test_ops_root_014_no_procedure_docs_in_ops,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-015".to_string()),
            title: "ops pillar markdown minimalism contract",
            tests: vec![TestCase {
                id: TestId("ops.root.no_extra_pillar_markdown".to_string()),
                title: "ops pillar markdown surface is restricted to allowlisted files",
                kind: TestKind::Pure,
                run: test_ops_root_015_no_extra_pillar_markdown,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-016".to_string()),
            title: "ops deleted markdown denylist contract",
            tests: vec![TestCase {
                id: TestId("ops.root.deleted_markdown_denylist".to_string()),
                title: "historically deleted markdown paths must not be reintroduced",
                kind: TestKind::Pure,
                run: test_ops_root_016_deleted_markdown_denylist,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-PILLARS-001".to_string()),
            title: "inventory pillars registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.pillars.exists_and_validates".to_string()),
                title: "pillars.json exists and validates",
                kind: TestKind::Pure,
                run: test_ops_inv_pillars_001_exists_and_validates,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-PILLARS-002".to_string()),
            title: "inventory pillar directory contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.pillars.every_pillar_dir_exists".to_string()),
                title: "every declared non-root pillar has a matching ops directory",
                kind: TestKind::Pure,
                run: test_ops_inv_pillars_002_every_pillar_dir_exists,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-PILLARS-003".to_string()),
            title: "inventory pillar strictness contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.pillars.no_extra_pillar_dirs".to_string()),
                title: "ops root has no undeclared pillar directories",
                kind: TestKind::Pure,
                run: test_ops_inv_pillars_003_no_extra_pillar_dirs,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-001".to_string()),
            title: "schema parseability contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.parseable_documents".to_string()),
                title: "ops json/yaml policy documents are parseable",
                kind: TestKind::Pure,
                run: test_ops_schema_001_parseable_documents,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-002".to_string()),
            title: "schema index completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.index_complete".to_string()),
                title: "generated schema index covers all schema sources",
                kind: TestKind::Pure,
                run: test_ops_schema_002_schema_index_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-003".to_string()),
            title: "schema naming contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.no_unversioned".to_string()),
                title: "schema sources use stable .schema.json naming",
                kind: TestKind::Pure,
                run: test_ops_schema_003_no_unversioned_schemas,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-004".to_string()),
            title: "schema budget contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.budget_policy".to_string()),
                title: "schema count stays within per-domain budgets",
                kind: TestKind::Pure,
                run: test_ops_schema_004_budget_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-005".to_string()),
            title: "schema evolution lock contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.evolution_lock".to_string()),
                title: "compatibility lock tracks schema evolution targets",
                kind: TestKind::Pure,
                run: test_ops_schema_005_evolution_lock,
            }],
        },
        Contract { id: ContractId("OPS-SCHEMA-006".to_string()), title: "schema id consistency contract", tests: vec![TestCase { id: TestId("ops.schema.id_and_naming_consistency".to_string()), title: "schema files define stable $id values aligned with file names", kind: TestKind::Pure, run: test_ops_schema_006_id_and_naming_consistency, }] },
        Contract { id: ContractId("OPS-SCHEMA-007".to_string()), title: "schema example validation contract", tests: vec![TestCase { id: TestId("ops.schema.examples_validate_required_fields".to_string()), title: "schema examples satisfy required field coverage from compatibility lock", kind: TestKind::Pure, run: test_ops_schema_007_examples_validate_required_fields, }] },
        Contract { id: ContractId("OPS-SCHEMA-008".to_string()), title: "schema intent uniqueness contract", tests: vec![TestCase { id: TestId("ops.schema.forbid_duplicate_intent".to_string()), title: "schema ids and titles are unique to avoid duplicated intent", kind: TestKind::Pure, run: test_ops_schema_008_forbid_duplicate_schema_intent, }] },
        Contract { id: ContractId("OPS-SCHEMA-009".to_string()), title: "schema canonical formatting contract", tests: vec![TestCase { id: TestId("ops.schema.canonical_json_formatting".to_string()), title: "generated schema artifacts use canonical pretty json formatting", kind: TestKind::Pure, run: test_ops_schema_009_canonical_json_formatting, }] },
        Contract { id: ContractId("OPS-SCHEMA-010".to_string()), title: "schema example coverage contract", tests: vec![TestCase { id: TestId("ops.schema.example_coverage".to_string()), title: "schema compatibility targets declare existing example fixtures", kind: TestKind::Pure, run: test_ops_schema_010_example_coverage, }] },
        Contract { id: ContractId("OPS-DATASETS-001".to_string()), title: "datasets manifest lock contract", tests: vec![TestCase { id: TestId("ops.datasets.manifest_and_lock_consistent".to_string()), title: "dataset manifest and lock ids are consistent", kind: TestKind::Pure, run: test_ops_dataset_001_manifest_and_lock, }] },
        Contract { id: ContractId("OPS-DATASETS-002".to_string()), title: "datasets fixture inventory contract", tests: vec![TestCase { id: TestId("ops.datasets.fixture_inventory_matches_disk".to_string()), title: "fixture inventory matches fixture directories and references", kind: TestKind::Pure, run: test_ops_dataset_002_fixture_inventory_matches_disk, }] },
        Contract { id: ContractId("OPS-DATASETS-003".to_string()), title: "datasets fixture drift promotion contract", tests: vec![TestCase { id: TestId("ops.datasets.no_fixture_drift_without_promotion_record".to_string()), title: "fixture drift requires explicit promotion rule coverage", kind: TestKind::Pure, run: test_ops_dataset_003_no_fixture_drift_without_promotion_record, }] },
        Contract { id: ContractId("OPS-DATASETS-004".to_string()), title: "datasets release diff determinism contract", tests: vec![TestCase { id: TestId("ops.datasets.release_diff_fixtures_deterministic".to_string()), title: "release-diff fixture lock and golden payloads are deterministic", kind: TestKind::Pure, run: test_ops_dataset_004_release_diff_fixtures_are_deterministic, }] },
        Contract { id: ContractId("OPS-DATASETS-005".to_string()), title: "datasets qc metadata summary contract", tests: vec![TestCase { id: TestId("ops.datasets.qc_metadata_and_golden_valid".to_string()), title: "qc metadata and summary golden are parseable and linked", kind: TestKind::Pure, run: test_ops_datasets_005_qc_metadata_and_golden_valid, }] },
        Contract { id: ContractId("OPS-DATASETS-006".to_string()), title: "datasets rollback policy contract", tests: vec![TestCase { id: TestId("ops.datasets.rollback_policy_exists_valid".to_string()), title: "rollback policy exists and includes required rollback structure", kind: TestKind::Pure, run: test_ops_datasets_006_rollback_policy_exists_valid, }] },
        Contract { id: ContractId("OPS-DATASETS-007".to_string()), title: "datasets promotion rules contract", tests: vec![TestCase { id: TestId("ops.datasets.promotion_rules_exists_valid".to_string()), title: "promotion rules exist with canonical environment coverage and pin references", kind: TestKind::Pure, run: test_ops_datasets_007_promotion_rules_exists_valid, }] },
        Contract { id: ContractId("OPS-DATASETS-008".to_string()), title: "datasets consumer interface contract", tests: vec![TestCase { id: TestId("ops.datasets.consumer_list_consistent_with_runtime_queries".to_string()), title: "consumer list interfaces resolve to runnable repository paths", kind: TestKind::Pure, run: test_ops_datasets_008_consumer_list_consistent_with_runtime_queries, }] },
        Contract { id: ContractId("OPS-DATASETS-009".to_string()), title: "datasets freeze policy contract", tests: vec![TestCase { id: TestId("ops.datasets.freeze_policy_exists_enforced".to_string()), title: "freeze policy enforces append-only fixture immutability", kind: TestKind::Pure, run: test_ops_datasets_009_freeze_policy_exists_enforced, }] },
        Contract { id: ContractId("OPS-DATASETS-010".to_string()), title: "datasets store layout contract", tests: vec![TestCase { id: TestId("ops.datasets.dataset_store_layout_contract_enforced".to_string()), title: "dataset ids and fixture paths follow canonical store layout", kind: TestKind::Pure, run: test_ops_datasets_010_dataset_store_layout_contract_enforced, }] },
        Contract {
            id: ContractId("OPS-E2E-001".to_string()),
            title: "e2e suites reference contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.suites_reference_real_scenarios".to_string()),
                title: "e2e suites reference concrete scenario ids and runnable entrypoints",
                kind: TestKind::Pure,
                run: test_ops_e2e_001_suites_reference_real_scenarios,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-002".to_string()),
            title: "e2e smoke manifest contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.smoke_manifest_valid".to_string()),
                title: "smoke manifest is structured and points to existing lock",
                kind: TestKind::Pure,
                run: test_ops_e2e_002_smoke_manifest_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-003".to_string()),
            title: "e2e fixtures lock contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.fixtures_lock_matches_allowlist".to_string()),
                title: "fixtures lock digest and fixture files match allowlist policy",
                kind: TestKind::Pure,
                run: test_ops_e2e_003_fixtures_lock_matches_allowlist,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-004".to_string()),
            title: "e2e realdata snapshot contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.realdata_snapshots_schema_valid_and_pinned".to_string()),
                title: "realdata snapshots are parseable and pinned to canonical queries",
                kind: TestKind::Pure,
                run: test_ops_e2e_004_realdata_snapshots_schema_valid_and_pinned,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-005".to_string()),
            title: "e2e taxonomy coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.taxonomy_covers_scenarios".to_string()),
                title: "taxonomy categories cover canonical scenario classification",
                kind: TestKind::Pure,
                run: test_ops_e2e_005_taxonomy_covers_scenarios,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-006".to_string()),
            title: "e2e reproducibility enforcement contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.reproducibility_policy_enforced".to_string()),
                title: "reproducibility policy checks and deterministic summary ordering are enforced",
                kind: TestKind::Pure,
                run: test_ops_e2e_006_reproducibility_policy_enforced,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-007".to_string()),
            title: "e2e coverage matrix determinism contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.coverage_matrix_deterministic".to_string()),
                title: "coverage matrix rows and coverage sets are complete and deterministic",
                kind: TestKind::Pure,
                run: test_ops_e2e_007_coverage_matrix_deterministic,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-008".to_string()),
            title: "e2e realdata scenario registry contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.realdata_registry_and_snapshots_valid".to_string()),
                title: "realdata scenarios and snapshots are structurally valid and runnable",
                kind: TestKind::Pure,
                run: test_ops_e2e_008_realdata_registry_and_snapshots_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-009".to_string()),
            title: "e2e surface artifact boundary contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.no_stray_e2e_artifacts".to_string()),
                title: "e2e root contains only declared artifact directories and files",
                kind: TestKind::Pure,
                run: test_ops_e2e_009_no_stray_e2e_artifacts,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-010".to_string()),
            title: "e2e summary schema contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.summary_schema_valid".to_string()),
                title: "e2e summary is schema-valid and aligned with suite/scenario registries",
                kind: TestKind::Pure,
                run: test_ops_e2e_010_summary_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-001".to_string()),
            title: "environment overlay schema contract",
            tests: vec![TestCase {
                id: TestId("ops.env.overlays_schema_valid".to_string()),
                title: "all required environment overlays are structurally valid",
                kind: TestKind::Pure,
                run: test_ops_env_001_overlays_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-002".to_string()),
            title: "environment profile completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.env.profiles_complete".to_string()),
                title: "base/ci/dev/prod overlays exist and match profile identity",
                kind: TestKind::Pure,
                run: test_ops_env_002_env_profiles_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-003".to_string()),
            title: "environment key strictness contract",
            tests: vec![TestCase {
                id: TestId("ops.env.no_unknown_keys".to_string()),
                title: "environment overlays reject unknown keys",
                kind: TestKind::Pure,
                run: test_ops_env_003_no_unknown_keys,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-004".to_string()),
            title: "environment overlay merge determinism contract",
            tests: vec![TestCase {
                id: TestId("ops.env.overlay_merge_deterministic".to_string()),
                title: "overlay merge with identical inputs is deterministic across profiles",
                kind: TestKind::Pure,
                run: test_ops_env_004_overlay_merge_deterministic,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-005".to_string()),
            title: "environment prod safety toggles contract",
            tests: vec![TestCase {
                id: TestId("ops.env.prod_forbids_dev_toggles".to_string()),
                title: "prod overlay forbids dev-only effect toggles and unrestricted network",
                kind: TestKind::Pure,
                run: test_ops_env_005_prod_forbids_dev_toggles,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-006".to_string()),
            title: "environment ci effect restriction contract",
            tests: vec![TestCase {
                id: TestId("ops.env.ci_restricts_effects".to_string()),
                title: "ci overlay disables subprocess effects and keeps restricted network mode",
                kind: TestKind::Pure,
                run: test_ops_env_006_ci_restricts_effects,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-007".to_string()),
            title: "environment base defaults contract",
            tests: vec![TestCase {
                id: TestId("ops.env.base_overlay_required_defaults".to_string()),
                title: "base overlay defines required default keys for all profiles",
                kind: TestKind::Pure,
                run: test_ops_env_007_base_overlay_required_defaults,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-008".to_string()),
            title: "environment overlay key stability contract",
            tests: vec![TestCase {
                id: TestId("ops.env.overlay_keys_stable".to_string()),
                title: "overlay key sets are stable and schema-versioned across base/dev/ci/prod",
                kind: TestKind::Pure,
                run: test_ops_env_008_overlay_keys_stable,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-009".to_string()),
            title: "environment overlays directory boundary contract",
            tests: vec![TestCase {
                id: TestId("ops.env.overlays_dir_no_stray_files".to_string()),
                title: "overlays directory has no stray files and portability matrix is present",
                kind: TestKind::Pure,
                run: test_ops_env_009_overlays_dir_no_stray_files,
            }],
        },
        Contract { id: ContractId("OPS-K8S-001".to_string()), title: "k8s static chart render contract", tests: vec![TestCase { id: TestId("ops.k8s.chart_renders_static".to_string()), title: "helm chart source includes required files and static render inputs", kind: TestKind::Pure, run: test_ops_k8s_001_chart_renders_static, }] },
        Contract { id: ContractId("OPS-K8S-002".to_string()), title: "k8s values schema validation contract", tests: vec![TestCase { id: TestId("ops.k8s.values_files_validate_schema".to_string()), title: "install-matrix values files exist and are parseable against chart schema surface", kind: TestKind::Pure, run: test_ops_k8s_002_values_files_validate_schema, }] },
        Contract { id: ContractId("OPS-K8S-003".to_string()), title: "k8s install matrix completeness contract", tests: vec![TestCase { id: TestId("ops.k8s.install_matrix_complete".to_string()), title: "install matrix covers canonical profile set and references existing files", kind: TestKind::Pure, run: test_ops_k8s_003_install_matrix_complete, }] },
        Contract { id: ContractId("OPS-K8S-004".to_string()), title: "k8s forbidden object policy contract", tests: vec![TestCase { id: TestId("ops.k8s.no_forbidden_k8s_objects".to_string()), title: "helm templates must not introduce forbidden cluster-scope object kinds", kind: TestKind::Pure, run: test_ops_k8s_004_no_forbidden_k8s_objects, }] },
        Contract { id: ContractId("OPS-K8S-005".to_string()), title: "k8s rbac minimalism contract", tests: vec![TestCase { id: TestId("ops.k8s.rbac_minimalism".to_string()), title: "helm templates must not declare cluster-admin or wildcard rbac grants", kind: TestKind::Pure, run: test_ops_k8s_005_rbac_minimalism, }] },
        Contract { id: ContractId("OPS-K8S-006".to_string()), title: "k8s pod security and probes contract", tests: vec![TestCase { id: TestId("ops.k8s.pod_security_and_probes".to_string()), title: "deployment template includes pod security hardening and readiness/liveness probes", kind: TestKind::Pure, run: test_ops_k8s_006_pod_security_and_probes, }] },
        Contract { id: ContractId("OPS-K8S-007".to_string()), title: "k8s rollout safety contract", tests: vec![TestCase { id: TestId("ops.k8s.rollout_safety_enforced".to_string()), title: "rollout safety contract is valid and rollout template enforces rollout steps", kind: TestKind::Pure, run: test_ops_k8s_007_rollout_safety_enforced, }] },
        Contract { id: ContractId("OPS-K8S-008".to_string()), title: "k8s conformance suite contract", tests: vec![TestCase { id: TestId("ops.k8s.conformance_suite_runnable".to_string()), title: "k8s conformance suite exists and control-plane exposes conformance verb", kind: TestKind::Pure, run: test_ops_k8s_008_conformance_suite_runnable, }] },
        Contract { id: ContractId("OPS-K8S-009".to_string()), title: "k8s install matrix generated consistency contract", tests: vec![TestCase { id: TestId("ops.k8s.install_matrix_and_generated_consistency".to_string()), title: "install matrix and generated k8s artifacts stay aligned and schema-versioned", kind: TestKind::Pure, run: test_ops_k8s_009_install_matrix_and_generated_consistency, }] },
        Contract { id: ContractId("OPS-K8S-010".to_string()), title: "k8s generated index determinism contract", tests: vec![TestCase { id: TestId("ops.k8s.generated_indexes_deterministic_schema_valid".to_string()), title: "generated k8s indexes are schema-versioned and deterministic", kind: TestKind::Pure, run: test_ops_k8s_010_generated_indexes_deterministic_schema_valid, }] },
        Contract {
            id: ContractId("OPS-LOAD-001".to_string()),
            title: "load scenario schema contract",
            tests: vec![TestCase {
                id: TestId("ops.load.scenarios_schema_valid".to_string()),
                title: "load scenarios are parseable and include required fields",
                kind: TestKind::Pure,
                run: test_ops_load_001_scenarios_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-002".to_string()),
            title: "load thresholds coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.load.thresholds_exist_for_each_suite".to_string()),
                title: "every load suite has a matching thresholds file",
                kind: TestKind::Pure,
                run: test_ops_load_002_thresholds_exist_for_each_suite,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-003".to_string()),
            title: "load pinned query lock contract",
            tests: vec![TestCase {
                id: TestId("ops.load.pinned_queries_lock_consistent".to_string()),
                title: "pinned query lock digests match source query payload",
                kind: TestKind::Pure,
                run: test_ops_load_003_pinned_queries_lock_consistent,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-004".to_string()),
            title: "load baseline schema contract",
            tests: vec![TestCase {
                id: TestId("ops.load.baselines_schema_valid".to_string()),
                title: "load baselines are parseable and contain required fields",
                kind: TestKind::Pure,
                run: test_ops_load_004_baselines_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-005".to_string()),
            title: "load scenario to slo mapping contract",
            tests: vec![TestCase {
                id: TestId("ops.load.no_scenario_without_slo_mapping".to_string()),
                title: "smoke/pr load suites must be represented in inventory SLO mappings",
                kind: TestKind::Pure,
                run: test_ops_load_005_no_scenario_without_slo_mapping,
            }],
        },
        Contract { id: ContractId("OPS-LOAD-006".to_string()), title: "load drift report schema contract", tests: vec![TestCase { id: TestId("ops.load.drift_report_generator_schema_valid".to_string()), title: "load drift report exists and is schema-valid", kind: TestKind::Pure, run: test_ops_load_006_drift_report_generator_schema_valid, }] },
        Contract { id: ContractId("OPS-LOAD-007".to_string()), title: "load result schema sample contract", tests: vec![TestCase { id: TestId("ops.load.result_schema_validates_sample_output".to_string()), title: "load result schema validates generated sample summary envelope", kind: TestKind::Pure, run: test_ops_load_007_result_schema_validates_sample_output, }] },
        Contract { id: ContractId("OPS-LOAD-008".to_string()), title: "load cheap survival suite gate contract", tests: vec![TestCase { id: TestId("ops.load.cheap_survival_in_minimal_gate_suite".to_string()), title: "cheap-only-survival suite is present in minimal gate lanes", kind: TestKind::Pure, run: test_ops_load_008_cheap_survival_in_minimal_gate_suite, }] },
        Contract { id: ContractId("OPS-LOAD-009".to_string()), title: "load cold start p99 suite gate contract", tests: vec![TestCase { id: TestId("ops.load.cold_start_p99_in_minimal_gate_suite".to_string()), title: "cold-start-p99 suite is present in required confidence lanes", kind: TestKind::Pure, run: test_ops_load_009_cold_start_p99_in_minimal_gate_suite, }] },
        Contract { id: ContractId("OPS-LOAD-010".to_string()), title: "load scenario slo impact mapping contract", tests: vec![TestCase { id: TestId("ops.load.every_scenario_has_slo_impact_class".to_string()), title: "every load suite maps to a scenario slo impact class entry", kind: TestKind::Pure, run: test_ops_load_010_every_scenario_has_slo_impact_class, }] },
        Contract {
            id: ContractId("OPS-OBS-001".to_string()),
            title: "observability alert rules contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.alert_rules_exist_parseable".to_string()),
                title: "required alert rule sources exist and are parseable",
                kind: TestKind::Pure,
                run: test_ops_obs_001_alert_rules_exist_parseable,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-002".to_string()),
            title: "observability dashboard golden contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.dashboard_json_parseable_golden_diff".to_string()),
                title: "dashboard json parses and matches golden identity and panel structure",
                kind: TestKind::Pure,
                run: test_ops_obs_002_dashboard_json_parseable_golden_diff,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-003".to_string()),
            title: "observability telemetry golden profile contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.telemetry_goldens_required_profiles".to_string()),
                title: "telemetry goldens exist for required profiles and are indexed",
                kind: TestKind::Pure,
                run: test_ops_obs_003_telemetry_goldens_required_profiles,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-004".to_string()),
            title: "observability readiness schema contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.readiness_schema_valid".to_string()),
                title: "readiness contract is parseable and uses canonical requirement set",
                kind: TestKind::Pure,
                run: test_ops_obs_004_readiness_schema_valid,
            }],
        },
        Contract { id: ContractId("OPS-OBS-005".to_string()), title: "observability alert catalog generation contract", tests: vec![TestCase { id: TestId("ops.observe.alert_catalog_generated_consistency".to_string()), title: "alert catalog is populated and aligned with parsed alert rules", kind: TestKind::Pure, run: test_ops_obs_005_alert_catalog_generated_consistency, }] },
        Contract { id: ContractId("OPS-OBS-006".to_string()), title: "observability slo burn-rate consistency contract", tests: vec![TestCase { id: TestId("ops.observe.slo_definitions_burn_rate_consistent".to_string()), title: "slo definitions and burn-rate rules remain aligned", kind: TestKind::Pure, run: test_ops_obs_006_slo_definitions_burn_rate_consistent, }] },
        Contract { id: ContractId("OPS-OBS-007".to_string()), title: "observability public surface coverage contract", tests: vec![TestCase { id: TestId("ops.observe.public_surface_coverage_matches_rules".to_string()), title: "public surface coverage rules include required surfaces", kind: TestKind::Pure, run: test_ops_obs_007_public_surface_coverage_matches_rules, }] },
        Contract { id: ContractId("OPS-OBS-008".to_string()), title: "observability telemetry index determinism contract", tests: vec![TestCase { id: TestId("ops.observe.telemetry_index_generated_deterministic".to_string()), title: "telemetry index is schema-versioned and sorted deterministically", kind: TestKind::Pure, run: test_ops_obs_008_telemetry_index_generated_deterministic, }] },
        Contract { id: ContractId("OPS-OBS-009".to_string()), title: "observability drills manifest contract", tests: vec![TestCase { id: TestId("ops.observe.drills_manifest_exists_runnable".to_string()), title: "drills manifest is populated with runnable drill definitions", kind: TestKind::Pure, run: test_ops_obs_009_drills_manifest_exists_runnable, }] },
        Contract { id: ContractId("OPS-OBS-010".to_string()), title: "observability overload behavior contract", tests: vec![TestCase { id: TestId("ops.observe.overload_behavior_contract_enforced".to_string()), title: "overload behavior contract exists and maps to load suite coverage", kind: TestKind::Pure, run: test_ops_obs_010_overload_behavior_contract_enforced, }] },
        Contract {
            id: ContractId("OPS-RPT-001".to_string()),
            title: "report schema ssot contract",
            tests: vec![TestCase {
                id: TestId("ops.report.schema_is_ssot".to_string()),
                title: "report schema is parseable and mirrored under ops/schema/report",
                kind: TestKind::Pure,
                run: test_ops_rpt_001_report_schema_ssot,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-002".to_string()),
            title: "report generated payload contract",
            tests: vec![TestCase {
                id: TestId("ops.report.generated_reports_schema_valid".to_string()),
                title: "generated report payloads are parseable and include schema_version",
                kind: TestKind::Pure,
                run: test_ops_rpt_002_generated_reports_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-003".to_string()),
            title: "report evidence levels contract",
            tests: vec![TestCase {
                id: TestId("ops.report.evidence_levels_complete".to_string()),
                title: "evidence levels include minimal standard and forensic",
                kind: TestKind::Pure,
                run: test_ops_rpt_003_evidence_levels_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-004".to_string()),
            title: "report diff structure contract",
            tests: vec![TestCase {
                id: TestId("ops.report.diff_contract_exists".to_string()),
                title: "generated report diff includes base target and change set",
                kind: TestKind::Pure,
                run: test_ops_rpt_004_report_diff_contract_exists,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-005".to_string()),
            title: "report readiness score determinism contract",
            tests: vec![TestCase {
                id: TestId("ops.report.readiness_score_deterministic".to_string()),
                title: "readiness score report is schema-versioned and uses canonical input keys",
                kind: TestKind::Pure,
                run: test_ops_rpt_005_readiness_score_deterministic,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-006".to_string()),
            title: "report release evidence bundle contract",
            tests: vec![TestCase {
                id: TestId("ops.report.release_evidence_bundle_schema_valid".to_string()),
                title: "release evidence bundle is parseable and references existing artifacts",
                kind: TestKind::Pure,
                run: test_ops_rpt_006_release_evidence_bundle_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-007".to_string()),
            title: "report historical comparison contract",
            tests: vec![TestCase {
                id: TestId("ops.report.historical_comparison_schema_valid".to_string()),
                title: "historical comparison report includes schema and readiness trend fields",
                kind: TestKind::Pure,
                run: test_ops_rpt_007_historical_comparison_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-008".to_string()),
            title: "report unified example contract",
            tests: vec![TestCase {
                id: TestId("ops.report.unified_report_example_schema_valid".to_string()),
                title: "unified report example includes required schema and summary sections",
                kind: TestKind::Pure,
                run: test_ops_rpt_008_unified_report_example_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-009".to_string()),
            title: "report canonical json output contract",
            tests: vec![TestCase {
                id: TestId("ops.report.outputs_canonical_json".to_string()),
                title: "report outputs are canonical pretty json with deterministic key ordering",
                kind: TestKind::Pure,
                run: test_ops_rpt_009_report_outputs_canonical_json,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-010".to_string()),
            title: "report lane aggregation contract",
            tests: vec![TestCase {
                id: TestId("ops.report.lane_reports_aggregated_in_unified_report".to_string()),
                title: "unified report summary totals are derived from lane report statuses",
                kind: TestKind::Pure,
                run: test_ops_rpt_010_lane_reports_aggregated_in_unified_report,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-001".to_string()),
            title: "stack toml profile contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.stack_toml_parseable_complete".to_string()),
                title: "stack.toml parses and includes canonical ci kind local profiles",
                kind: TestKind::Pure,
                run: test_ops_stack_001_stack_toml_parseable_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-002".to_string()),
            title: "stack service dependency contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.service_dependency_contract_valid".to_string()),
                title: "service dependency contract entries are parseable and resolve to files",
                kind: TestKind::Pure,
                run: test_ops_stack_002_service_dependency_contract_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-003".to_string()),
            title: "stack version manifest contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.versions_manifest_schema_valid".to_string()),
                title: "version manifest is parseable and image refs are digest pinned",
                kind: TestKind::Pure,
                run: test_ops_stack_003_versions_manifest_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-004".to_string()),
            title: "stack dependency graph contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.dependency_graph_generated_acyclic".to_string()),
                title: "dependency graph is parseable and references real cluster/components",
                kind: TestKind::Pure,
                run: test_ops_stack_004_dependency_graph_generated_acyclic,
            }],
        },
        Contract { id: ContractId("OPS-STACK-005".to_string()), title: "stack kind profile consistency contract", tests: vec![TestCase { id: TestId("ops.stack.kind_profiles_consistent".to_string()), title: "dev perf and small kind profiles exist and reference valid cluster configs", kind: TestKind::Pure, run: test_ops_stack_005_kind_profiles_consistent, }] },
        Contract { id: ContractId("OPS-STACK-006".to_string()), title: "stack ports inventory consistency contract", tests: vec![TestCase { id: TestId("ops.stack.ports_inventory_matches_stack".to_string()), title: "ports inventory endpoints are unique and aligned with stack components", kind: TestKind::Pure, run: test_ops_stack_006_ports_inventory_matches_stack, }] },
        Contract { id: ContractId("OPS-STACK-007".to_string()), title: "stack health report generator contract", tests: vec![TestCase { id: TestId("ops.stack.health_report_generator_contract".to_string()), title: "health report sample has schema envelope and stack generator provenance", kind: TestKind::Pure, run: test_ops_stack_007_health_report_generator_contract, }] },
        Contract { id: ContractId("OPS-STACK-008".to_string()), title: "stack command surface contract", tests: vec![TestCase { id: TestId("ops.stack.stack_commands_registered".to_string()), title: "stack command surface snapshot contains up and down verbs", kind: TestKind::Pure, run: test_ops_stack_008_stack_commands_registered, }] },
        Contract { id: ContractId("OPS-STACK-009".to_string()), title: "stack offline profile policy contract", tests: vec![TestCase { id: TestId("ops.stack.offline_profile_policy".to_string()), title: "offline claims require offline or airgap profile coverage", kind: TestKind::Pure, run: test_ops_stack_009_offline_profile_policy, }] },
        Contract {
            id: ContractId("OPS-STACK-E-001".to_string()),
            title: "stack effect kind cluster contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.kind_cluster_up_profile_dev".to_string()),
                title: "effect lane requires kind dev cluster contract inputs",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_001_kind_cluster_up_profile_dev,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-E-002".to_string()),
            title: "stack effect component rollout contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.core_components_present".to_string()),
                title: "effect lane requires core stack component manifests",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_002_core_components_present,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-E-003".to_string()),
            title: "stack effect ports inventory contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.ports_inventory_mapped".to_string()),
                title: "effect lane requires stack ports inventory contract sample",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_003_ports_inventory_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-E-004".to_string()),
            title: "stack effect health report contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.health_report_generated".to_string()),
                title: "effect lane requires stack health report contract sample",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_004_stack_health_report_generated,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-E-001".to_string()),
            title: "k8s effect helm install contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.effect.helm_install_contract_defined".to_string()),
                title: "effect lane requires kind install profile in k8s install matrix",
                kind: TestKind::Subprocess,
                run: test_ops_k8s_e_001_helm_install_contract_defined,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-E-002".to_string()),
            title: "k8s effect rollout safety contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.effect.rollout_safety_contract_satisfied".to_string()),
                title: "effect lane requires rollout safety contract checks",
                kind: TestKind::Subprocess,
                run: test_ops_k8s_e_002_rollout_safety_contract_satisfied,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-E-003".to_string()),
            title: "k8s effect endpoint reachability contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.effect.service_endpoints_reachable_contract".to_string()),
                title: "effect lane requires non-empty k8s suite coverage for endpoint checks",
                kind: TestKind::Network,
                run: test_ops_k8s_e_003_service_endpoints_reachable_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-E-001".to_string()),
            title: "observe effect metrics scrape contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.effect.scrape_metrics_contract".to_string()),
                title: "effect lane requires non-empty metrics scrape contract",
                kind: TestKind::Network,
                run: test_ops_obs_e_001_scrape_metrics_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-E-002".to_string()),
            title: "observe effect trace structure contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.effect.trace_structure_contract".to_string()),
                title: "effect lane requires trace structure golden contract",
                kind: TestKind::Network,
                run: test_ops_obs_e_002_trace_structure_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-E-003".to_string()),
            title: "observe effect alerts load contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.effect.alerts_load_contract".to_string()),
                title: "effect lane requires parseable alert rule inputs",
                kind: TestKind::Network,
                run: test_ops_obs_e_003_alerts_load_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-E-001".to_string()),
            title: "load effect k6 execution contract",
            tests: vec![TestCase {
                id: TestId("ops.load.effect.k6_suite_executes_contract".to_string()),
                title: "effect lane requires at least one k6 load suite definition",
                kind: TestKind::Subprocess,
                run: test_ops_load_e_001_k6_suite_executes_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-E-002".to_string()),
            title: "load effect thresholds report contract",
            tests: vec![TestCase {
                id: TestId("ops.load.effect.thresholds_enforced_report_emitted".to_string()),
                title: "effect lane requires thresholds contract and emitted load summary report",
                kind: TestKind::Subprocess,
                run: test_ops_load_e_002_thresholds_enforced_report_emitted,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-E-003".to_string()),
            title: "load effect baseline comparison contract",
            tests: vec![TestCase {
                id: TestId("ops.load.effect.baseline_comparison_produced".to_string()),
                title: "effect lane requires emitted load drift comparison report",
                kind: TestKind::Subprocess,
                run: test_ops_load_e_003_baseline_comparison_produced,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-E-001".to_string()),
            title: "e2e effect smoke suite contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.effect.smoke_suite_passes_contract".to_string()),
                title: "effect lane requires smoke suite declaration in e2e suite registry",
                kind: TestKind::Subprocess,
                run: test_ops_e2e_e_001_smoke_suite_passes_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-E-002".to_string()),
            title: "e2e effect realdata suite contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.effect.realdata_scenario_passes_contract".to_string()),
                title: "effect lane requires non-empty realdata scenario contract set",
                kind: TestKind::Subprocess,
                run: test_ops_e2e_e_002_realdata_scenario_passes_contract,
            }],
        },
    ];
    validate_registry(&rows, repo_root)?;
    Ok(rows)
}

pub fn contract_explain(contract_id: &str) -> &'static str {
    match contract_id {
        "OPS-000" => "Defines the only allowed root ops filesystem surface and markdown envelope.",
        "OPS-001" => "Governs generated artifact lifecycle boundaries under _generated and _generated.example.",
        "OPS-002" => "Requires per-domain README/CONTRACT and forbids legacy duplicate docs.",
        "OPS-003" => "Enforces markdown size budgets so contracts stay concise and reviewable.",
        "OPS-004" => "Enforces SSOT boundary: ops README is navigation-only and points to docs/operations.",
        "OPS-005" => "Ensures ops/CONTRACT.md is generated from and synchronized with registry metadata.",
        "OPS-ROOT-001" => "Constrains ops root surface to canonical control-plane files and domain directories.",
        "OPS-ROOT-002" => "Forbids extra markdown documents at ops root beyond README.md and CONTRACT.md.",
        "OPS-ROOT-003" => "Forbids shell script artifacts and bash shebangs in ops policy/config trees.",
        "OPS-ROOT-004" => "Enforces directory-depth budget for ops artifacts to avoid uncontrolled nesting.",
        "OPS-ROOT-005" => "Enforces stable filename policy with explicit allowlisted exceptions.",
        "OPS-ROOT-006" => "Requires gitignore policy for runtime-generated ops/_generated artifacts.",
        "OPS-ROOT-007" => "Guards committed generated examples against secret-like payload leakage.",
        "OPS-ROOT-008" => "Requires placeholder directories to be explicitly listed in inventory allowlist.",
        "OPS-ROOT-009" => "Requires ops policy/config artifacts to be covered by inventory mappings.",
        "OPS-ROOT-010" => "Prevents reintroduction of deleted legacy ops markdown policy documents.",
        "OPS-DOCS-001" => "Ensures operations docs policy statements reference executable OPS contract IDs.",
        "OPS-INV-001" => "Ensures domain and policy registration completeness in inventory sources.",
        "OPS-INV-002" => "Prevents orphan ops files that are not mapped by inventory references.",
        "OPS-INV-003" => "Forbids duplicate SSOT markdown documents when inventory is authoritative.",
        "OPS-INV-004" => "Enforces authority-tier exception structure with explicit expiry metadata.",
        "OPS-INV-005" => "Validates inventory control-graph integrity, mappings, and cycle safety.",
        "OPS-INV-006" => "Validates contract id format consistency in the ops contract registry.",
        "OPS-INV-007" => "Ensures gates registry exists with one unique mapped action per gate id.",
        "OPS-INV-008" => "Ensures drills registry ids map to runnable observability drill definitions.",
        "OPS-INV-009" => "Ensures owners registry covers each canonical ops domain directory.",
        "OPS-INV-010" => "Ensures required inventory schema files exist under ops/schema/inventory.",
        "OPS-INV-MAP-001" => "Ensures every contract id is present in contract-gate-map mappings.",
        "OPS-INV-MAP-002" => "Ensures mapped gate ids resolve to declared entries in gates registry.",
        "OPS-INV-MAP-003" => "Ensures mapped commands exist in the ops command surface router snapshot.",
        "OPS-INV-MAP-004" => "Ensures effects annotations in map align with contract test kind modes.",
        "OPS-INV-MAP-005" => "Ensures no gate id is orphaned outside contract-gate-map references.",
        "OPS-INV-MAP-006" => "Ensures every contract maps to gates or is explicitly static-only.",
        "OPS-INV-MAP-007" => "Ensures static-only map entries refer only to pure test contracts.",
        "OPS-INV-MAP-008" => "Ensures effect mappings use effectful test kinds and explicit effect annotations.",
        "OPS-INV-MAP-009" => "Ensures explain mapping source includes gate ids for non-static contracts.",
        "OPS-INV-MAP-010" => "Ensures contract-gate-map is sorted by contract id and canonical json format.",
        "OPS-ROOT-SURFACE-001" => "Ensures required ops stack/k8s/load/observe/list commands exist in router surface.",
        "OPS-ROOT-SURFACE-002" => "Ensures listed command surface equals action dispatch surface with no hidden commands.",
        "OPS-ROOT-SURFACE-003" => "Ensures command surface list ordering is deterministic.",
        "OPS-ROOT-SURFACE-004" => "Ensures mapped commands include explicit effects_required declarations.",
        "OPS-ROOT-SURFACE-005" => "Ensures command actions are grouped only under approved pillar-style domains.",
        "OPS-ROOT-SURFACE-006" => "Forbids ad-hoc command group domains such as misc/util.",
        "OPS-ROOT-SURFACE-007" => "Ensures each command action declares a stable purpose string.",
        "OPS-ROOT-SURFACE-008" => "Ensures each command action declares json output support.",
        "OPS-ROOT-SURFACE-009" => "Ensures each command action declares dry-run policy metadata.",
        "OPS-ROOT-SURFACE-010" => "Ensures each command action declares artifacts root write policy.",
        "OPS-ROOT-011" => "Restricts ops markdown files to explicit allowlisted paths.",
        "OPS-ROOT-012" => "Ensures each non-root pillar has exactly one README.md at pillar root.",
        "OPS-ROOT-013" => "Ensures markdown allowlist inventory file exists and is non-empty.",
        "OPS-ROOT-014" => "Ensures procedure/policy language in ops markdown is linked to OPS contract IDs.",
        "OPS-ROOT-015" => "Enforces minimal pillar markdown surface via allowlist.",
        "OPS-ROOT-016" => "Prevents reintroduction of historically deleted markdown paths via denylist.",
        "OPS-INV-PILLARS-001" => "Validates pillars SSOT exists and parses as inventory metadata.",
        "OPS-INV-PILLARS-002" => "Validates each declared pillar has a concrete directory under ops/.",
        "OPS-INV-PILLARS-003" => "Validates there are no undeclared pillar directories in ops root.",
        "OPS-SCHEMA-001" => "Ensures ops json/yaml policy documents are parseable.",
        "OPS-SCHEMA-002" => "Ensures generated schema index matches on-disk schema sources.",
        "OPS-SCHEMA-003" => "Enforces stable .schema.json naming for schema source files.",
        "OPS-SCHEMA-004" => "Enforces per-domain schema count budgets to limit sprawl.",
        "OPS-SCHEMA-005" => "Requires compatibility lock coverage for schema evolution governance.",
        "OPS-SCHEMA-006" => "Ensures schema files declare stable $id values aligned with file names.",
        "OPS-SCHEMA-007" => "Ensures schema examples cover required fields declared in compatibility lock.",
        "OPS-SCHEMA-008" => "Prevents duplicate schema $id or title intent across schema sources.",
        "OPS-SCHEMA-009" => "Enforces canonical pretty JSON formatting for generated schema artifacts.",
        "OPS-SCHEMA-010" => "Ensures each compatibility-lock schema target declares an existing example fixture.",
        "OPS-DATASETS-001" => "Ensures datasets manifest and lock use the same dataset id set.",
        "OPS-DATASETS-002" => "Ensures fixture inventory maps cleanly to fixture directories and references.",
        "OPS-DATASETS-003" => "Requires fixture drift to be covered by explicit promotion policy metadata.",
        "OPS-DATASETS-004" => "Ensures release-diff fixture assets and goldens stay deterministic and pinned.",
        "OPS-DATASETS-005" => "Ensures dataset qc metadata references a parseable qc summary golden.",
        "OPS-DATASETS-006" => "Ensures rollback policy exists and provides required rollback structure.",
        "OPS-DATASETS-007" => "Ensures promotion rules declare canonical environments and required pin sources.",
        "OPS-DATASETS-008" => "Ensures dataset consumer interfaces point at existing runnable repository artifacts.",
        "OPS-DATASETS-009" => "Ensures dataset freeze policy enforces append-only and non-replacement immutability.",
        "OPS-DATASETS-010" => "Ensures dataset ids and fixture paths follow canonical store layout conventions.",
        "OPS-E2E-001" => "Ensures e2e suites map to concrete scenario ids and runnable scripts.",
        "OPS-E2E-002" => "Ensures smoke manifest structure and lock references are valid.",
        "OPS-E2E-003" => "Ensures fixture lock digest and allowlist file policy remain consistent.",
        "OPS-E2E-004" => "Ensures realdata snapshots are parseable and pinned to canonical queries.",
        "OPS-E2E-005" => "Ensures taxonomy categories classify each declared e2e scenario.",
        "OPS-E2E-006" => "Ensures reproducibility policy and deterministic e2e summary ordering are enforced.",
        "OPS-E2E-007" => "Ensures coverage matrix rows and coverage sets are deterministic and complete.",
        "OPS-E2E-008" => "Ensures realdata scenarios and snapshots are structurally valid and runnable.",
        "OPS-E2E-009" => "Ensures e2e directory surface is restricted to declared artifacts only.",
        "OPS-E2E-010" => "Ensures e2e summary is schema-valid and aligned with suite/scenario registries.",
        "OPS-ENV-001" => "Ensures required environment overlays satisfy structural schema rules.",
        "OPS-ENV-002" => "Ensures base/ci/dev/prod overlay coverage and profile identity consistency.",
        "OPS-ENV-003" => "Enforces strict known-key policy for environment overlay payloads.",
        "OPS-ENV-004" => "Ensures overlay merge behavior is deterministic for identical profile inputs.",
        "OPS-ENV-005" => "Ensures prod overlay forbids dev-only effect toggles and unrestricted network mode.",
        "OPS-ENV-006" => "Ensures ci overlay keeps subprocess effects disabled and restricted networking.",
        "OPS-ENV-007" => "Ensures base overlay defines required default keys consumed across environments.",
        "OPS-ENV-008" => "Ensures overlay values keys remain stable and schema-versioned across profiles.",
        "OPS-ENV-009" => "Ensures overlays directory has no stray files and portability matrix exists.",
        "OPS-K8S-001" => "Ensures helm chart sources expose static render prerequisites.",
        "OPS-K8S-002" => "Ensures install-matrix values files exist and parse against chart schema surface.",
        "OPS-K8S-003" => "Ensures install-matrix covers canonical k8s profile set and file references.",
        "OPS-K8S-004" => "Forbids disallowed cluster-scope object kinds in helm templates.",
        "OPS-K8S-005" => "Forbids cluster-admin and wildcard RBAC grants in k8s chart templates.",
        "OPS-K8S-006" => "Ensures deployment template includes pod security hardening and probes.",
        "OPS-K8S-007" => "Ensures rollout safety contract fields are valid and rollout chart enforces steps.",
        "OPS-K8S-008" => "Ensures conformance suite declarations exist and are wired into ops command surface.",
        "OPS-K8S-009" => "Ensures install matrix aligns with generated k8s release and render indexes.",
        "OPS-K8S-010" => "Ensures generated k8s indexes are schema-versioned and deterministically ordered.",
        "OPS-LOAD-001" => "Ensures load scenarios are parseable and keep required fields.",
        "OPS-LOAD-002" => "Ensures each load suite has a matching thresholds artifact.",
        "OPS-LOAD-003" => "Ensures pinned query lock digests match source query payload.",
        "OPS-LOAD-004" => "Ensures load baselines are parseable and include required structure.",
        "OPS-LOAD-005" => "Ensures smoke/pr load suites are covered by inventory SLO mappings.",
        "OPS-LOAD-006" => "Ensures load drift report artifact exists and includes schema envelope fields.",
        "OPS-LOAD-007" => "Ensures load result schema and generated sample summary stay structurally aligned.",
        "OPS-LOAD-008" => "Ensures cheap-only-survival suite is retained in minimal confidence gate lanes.",
        "OPS-LOAD-009" => "Ensures cold-start-p99 suite is retained in required confidence gate lanes.",
        "OPS-LOAD-010" => "Ensures each declared load suite maps to scenario SLO impact coverage.",
        "OPS-OBS-001" => "Ensures observability alert rules exist and are parseable.",
        "OPS-OBS-002" => "Ensures observability dashboard json aligns with committed golden identity.",
        "OPS-OBS-003" => "Ensures telemetry goldens for required profiles exist and are indexed.",
        "OPS-OBS-004" => "Ensures readiness contract is parseable and contains canonical requirements.",
        "OPS-OBS-005" => "Ensures alert catalog is populated and aligned with parsed alert rule sources.",
        "OPS-OBS-006" => "Ensures SLO definitions and burn-rate alert rules remain semantically aligned.",
        "OPS-OBS-007" => "Ensures public observability surface coverage rules include required surfaces.",
        "OPS-OBS-008" => "Ensures telemetry index artifacts remain schema-versioned and deterministic.",
        "OPS-OBS-009" => "Ensures observability drills manifest includes runnable drill definitions.",
        "OPS-OBS-010" => "Ensures overload behavior contract exists and is mapped to load-suite enforcement coverage.",
        "OPS-RPT-001" => "Ensures report schema is the SSOT and mirrored under ops/schema/report.",
        "OPS-RPT-002" => "Ensures generated report payloads are parseable and include schema_version.",
        "OPS-RPT-003" => "Ensures report evidence levels include minimal standard and forensic tiers.",
        "OPS-RPT-004" => "Ensures generated report diff includes base target and change structure.",
        "OPS-RPT-005" => "Ensures readiness score report is deterministic and keyed by canonical input sources.",
        "OPS-RPT-006" => "Ensures release evidence bundle is parseable and references existing report artifacts.",
        "OPS-RPT-007" => "Ensures historical comparison report includes required trend and readiness signals.",
        "OPS-RPT-008" => "Ensures unified report example contains required schema, lane, summary, and budget sections.",
        "OPS-RPT-009" => "Ensures report outputs use canonical pretty JSON formatting and deterministic key ordering.",
        "OPS-RPT-010" => "Ensures unified report summary is an aggregate of emitted per-lane statuses.",
        "OPS-STACK-001" => "Ensures stack.toml parses and defines canonical execution profiles.",
        "OPS-STACK-002" => "Ensures service dependency contract entries are structurally valid.",
        "OPS-STACK-003" => "Ensures stack version manifest is parseable and digest pinned.",
        "OPS-STACK-004" => "Ensures stack dependency graph references real assets and consistent profile links.",
        "OPS-STACK-005" => "Ensures dev/perf/small kind profile coverage and required cluster config fields.",
        "OPS-STACK-006" => "Ensures stack ports inventory endpoint mapping is unique and component-aware.",
        "OPS-STACK-007" => "Ensures stack health report evidence carries schema envelope and generator provenance.",
        "OPS-STACK-008" => "Ensures stack up/down verbs remain present in control-plane command surface snapshot.",
        "OPS-STACK-009" => "Ensures offline or airgap claims are backed by explicit stack profile entries.",
        "OPS-STACK-E-001" => "Effect lane contract for kind dev cluster bring-up inputs.",
        "OPS-STACK-E-002" => "Effect lane contract for core stack component rollout manifests.",
        "OPS-STACK-E-003" => "Effect lane contract for stack ports inventory mapping evidence.",
        "OPS-STACK-E-004" => "Effect lane contract for stack health report evidence.",
        "OPS-K8S-E-001" => "Effect lane contract for helm install profile coverage in k8s matrix.",
        "OPS-K8S-E-002" => "Effect lane contract for rollout safety checks declaration.",
        "OPS-K8S-E-003" => "Effect lane contract for service endpoint reachability suite coverage.",
        "OPS-OBS-E-001" => "Effect lane contract for metrics scrape evidence input.",
        "OPS-OBS-E-002" => "Effect lane contract for trace structure evidence input.",
        "OPS-OBS-E-003" => "Effect lane contract for alert rule loading inputs.",
        "OPS-LOAD-E-001" => "Effect lane contract for executable k6 load suite coverage.",
        "OPS-LOAD-E-002" => "Effect lane contract for threshold enforcement and load summary emission.",
        "OPS-LOAD-E-003" => "Effect lane contract for emitted load baseline drift comparison.",
        "OPS-E2E-E-001" => "Effect lane contract for smoke suite declaration in e2e registry.",
        "OPS-E2E-E-002" => "Effect lane contract for realdata scenario declaration in e2e registry.",
        _ => "No explanation registered for this contract id.",
    }
}
