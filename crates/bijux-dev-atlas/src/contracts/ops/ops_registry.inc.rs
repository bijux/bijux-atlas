pub fn contracts(_repo_root: &Path) -> Result<Vec<Contract>, String> {
    Ok(vec![
        Contract {
            id: ContractId("OPS-000".to_string()),
            title: "ops directory contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.dir.allowed_root_files".to_string()),
                    title: "ops root allows only contract/readme root files",
                    kind: TestKind::Pure,
                    run: test_ops_000_allowed_root_files,
                },
                TestCase {
                    id: TestId("ops.dir.forbid_extra_markdown_root".to_string()),
                    title: "ops root forbids extra markdown",
                    kind: TestKind::Pure,
                    run: test_ops_000_forbid_extra_markdown_root,
                },
                TestCase {
                    id: TestId("ops.dir.allow_only_known_domain_dirs".to_string()),
                    title: "ops root allows only canonical domain directories",
                    kind: TestKind::Pure,
                    run: test_ops_000_allow_only_known_domain_dirs,
                },
                TestCase {
                    id: TestId("ops.dir.forbid_extra_markdown_recursive".to_string()),
                    title: "ops forbids recursive markdown outside approved surface",
                    kind: TestKind::Pure,
                    run: test_ops_000_forbid_extra_markdown_recursive,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-001".to_string()),
            title: "ops generated lifecycle contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.generated.runtime.allowed_files".to_string()),
                    title: "ops/_generated allows only runtime artifact formats",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_runtime_allowed_files,
                },
                TestCase {
                    id: TestId("ops.generated.example.allowed_files".to_string()),
                    title: "ops/_generated.example allows only committed artifact formats",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_example_allowed_files,
                },
                TestCase {
                    id: TestId("ops.generated.runtime.no_example_files".to_string()),
                    title: "ops/_generated forbids example artifacts",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_runtime_forbid_example_files,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-002".to_string()),
            title: "ops required domain files contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.domain.required_contract_and_readme".to_string()),
                    title: "each ops domain includes README.md and CONTRACT.md",
                    kind: TestKind::Pure,
                    run: test_ops_002_domain_required_files,
                },
                TestCase {
                    id: TestId("ops.domain.forbid_legacy_docs".to_string()),
                    title: "legacy domain INDEX/OWNER/REQUIRED markdown files are forbidden",
                    kind: TestKind::Pure,
                    run: test_ops_002_forbid_legacy_domain_docs,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-003".to_string()),
            title: "ops markdown budget contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.markdown_budget.readme".to_string()),
                    title: "README markdown files stay within line budget",
                    kind: TestKind::Pure,
                    run: test_ops_003_readme_markdown_budget,
                },
                TestCase {
                    id: TestId("ops.markdown_budget.contract".to_string()),
                    title: "CONTRACT markdown files stay within line budget",
                    kind: TestKind::Pure,
                    run: test_ops_003_contract_markdown_budget,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-004".to_string()),
            title: "ops docs ssot boundary contract",
            tests: vec![TestCase {
                id: TestId("ops.docs.readme_ssot_boundary".to_string()),
                title: "ops root readme remains navigation-only and references docs/operations",
                kind: TestKind::Pure,
                run: test_ops_004_readme_ssot_boundary,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-001".to_string()),
            title: "inventory completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.completeness".to_string()),
                title: "inventory registers all domains and policy files",
                kind: TestKind::Pure,
                run: test_ops_inv_001_inventory_completeness,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-002".to_string()),
            title: "inventory orphan files contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.no_orphan_files".to_string()),
                title: "ops files must be mapped through inventory sources",
                kind: TestKind::Pure,
                run: test_ops_inv_002_no_orphan_files,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-003".to_string()),
            title: "inventory duplicate source contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.no_duplicate_ssot_sources".to_string()),
                title: "duplicate ssot markdown sources are forbidden",
                kind: TestKind::Pure,
                run: test_ops_inv_003_no_duplicate_ssot,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-004".to_string()),
            title: "inventory authority tier contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.authority_tiers_enforced".to_string()),
                title: "authority tier exceptions are structured and expiry-bound",
                kind: TestKind::Pure,
                run: test_ops_inv_004_authority_tiers_enforced,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-005".to_string()),
            title: "inventory control graph contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.control_graph_validated".to_string()),
                title: "control graph edges and node mappings are valid and acyclic",
                kind: TestKind::Pure,
                run: test_ops_inv_005_control_graph_validated,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-001".to_string()),
            title: "schema parseability contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.parseable_documents".to_string()),
                title: "ops json/yaml policy documents are parseable",
                kind: TestKind::Pure,
                run: test_ops_schema_001_parseable_documents,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-002".to_string()),
            title: "schema index completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.index_complete".to_string()),
                title: "generated schema index covers all schema sources",
                kind: TestKind::Pure,
                run: test_ops_schema_002_schema_index_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-003".to_string()),
            title: "schema naming contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.no_unversioned".to_string()),
                title: "schema sources use stable .schema.json naming",
                kind: TestKind::Pure,
                run: test_ops_schema_003_no_unversioned_schemas,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-004".to_string()),
            title: "schema budget contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.budget_policy".to_string()),
                title: "schema count stays within per-domain budgets",
                kind: TestKind::Pure,
                run: test_ops_schema_004_budget_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-005".to_string()),
            title: "schema evolution lock contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.evolution_lock".to_string()),
                title: "compatibility lock tracks schema evolution targets",
                kind: TestKind::Pure,
                run: test_ops_schema_005_evolution_lock,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-001".to_string()),
            title: "datasets manifest lock contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.manifest_and_lock_consistent".to_string()),
                title: "dataset manifest and lock ids are consistent",
                kind: TestKind::Pure,
                run: test_ops_dataset_001_manifest_and_lock,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-002".to_string()),
            title: "datasets fixture inventory contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.fixture_inventory_matches_disk".to_string()),
                title: "fixture inventory matches fixture directories and references",
                kind: TestKind::Pure,
                run: test_ops_dataset_002_fixture_inventory_matches_disk,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-003".to_string()),
            title: "datasets fixture drift promotion contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.no_fixture_drift_without_promotion_record".to_string()),
                title: "fixture drift requires explicit promotion rule coverage",
                kind: TestKind::Pure,
                run: test_ops_dataset_003_no_fixture_drift_without_promotion_record,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-004".to_string()),
            title: "datasets release diff determinism contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.release_diff_fixtures_deterministic".to_string()),
                title: "release-diff fixture lock and golden payloads are deterministic",
                kind: TestKind::Pure,
                run: test_ops_dataset_004_release_diff_fixtures_are_deterministic,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-001".to_string()),
            title: "e2e suites reference contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.suites_reference_real_scenarios".to_string()),
                title: "e2e suites reference concrete scenario ids and runnable entrypoints",
                kind: TestKind::Pure,
                run: test_ops_e2e_001_suites_reference_real_scenarios,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-002".to_string()),
            title: "e2e smoke manifest contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.smoke_manifest_valid".to_string()),
                title: "smoke manifest is structured and points to existing lock",
                kind: TestKind::Pure,
                run: test_ops_e2e_002_smoke_manifest_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-003".to_string()),
            title: "e2e fixtures lock contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.fixtures_lock_matches_allowlist".to_string()),
                title: "fixtures lock digest and fixture files match allowlist policy",
                kind: TestKind::Pure,
                run: test_ops_e2e_003_fixtures_lock_matches_allowlist,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-004".to_string()),
            title: "e2e realdata snapshot contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.realdata_snapshots_schema_valid_and_pinned".to_string()),
                title: "realdata snapshots are parseable and pinned to canonical queries",
                kind: TestKind::Pure,
                run: test_ops_e2e_004_realdata_snapshots_schema_valid_and_pinned,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-001".to_string()),
            title: "environment overlay schema contract",
            tests: vec![TestCase {
                id: TestId("ops.env.overlays_schema_valid".to_string()),
                title: "all required environment overlays are structurally valid",
                kind: TestKind::Pure,
                run: test_ops_env_001_overlays_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-002".to_string()),
            title: "environment profile completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.env.profiles_complete".to_string()),
                title: "base/ci/dev/prod overlays exist and match profile identity",
                kind: TestKind::Pure,
                run: test_ops_env_002_env_profiles_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-003".to_string()),
            title: "environment key strictness contract",
            tests: vec![TestCase {
                id: TestId("ops.env.no_unknown_keys".to_string()),
                title: "environment overlays reject unknown keys",
                kind: TestKind::Pure,
                run: test_ops_env_003_no_unknown_keys,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-001".to_string()),
            title: "k8s static chart render contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.chart_renders_static".to_string()),
                title: "helm chart source includes required files and static render inputs",
                kind: TestKind::Pure,
                run: test_ops_k8s_001_chart_renders_static,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-002".to_string()),
            title: "k8s values schema validation contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.values_files_validate_schema".to_string()),
                title: "install-matrix values files exist and are parseable against chart schema surface",
                kind: TestKind::Pure,
                run: test_ops_k8s_002_values_files_validate_schema,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-003".to_string()),
            title: "k8s install matrix completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.install_matrix_complete".to_string()),
                title: "install matrix covers canonical profile set and references existing files",
                kind: TestKind::Pure,
                run: test_ops_k8s_003_install_matrix_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-004".to_string()),
            title: "k8s forbidden object policy contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.no_forbidden_k8s_objects".to_string()),
                title: "helm templates must not introduce forbidden cluster-scope object kinds",
                kind: TestKind::Pure,
                run: test_ops_k8s_004_no_forbidden_k8s_objects,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-001".to_string()),
            title: "load scenario schema contract",
            tests: vec![TestCase {
                id: TestId("ops.load.scenarios_schema_valid".to_string()),
                title: "load scenarios are parseable and include required fields",
                kind: TestKind::Pure,
                run: test_ops_load_001_scenarios_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-002".to_string()),
            title: "load thresholds coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.load.thresholds_exist_for_each_suite".to_string()),
                title: "every load suite has a matching thresholds file",
                kind: TestKind::Pure,
                run: test_ops_load_002_thresholds_exist_for_each_suite,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-003".to_string()),
            title: "load pinned query lock contract",
            tests: vec![TestCase {
                id: TestId("ops.load.pinned_queries_lock_consistent".to_string()),
                title: "pinned query lock digests match source query payload",
                kind: TestKind::Pure,
                run: test_ops_load_003_pinned_queries_lock_consistent,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-004".to_string()),
            title: "load baseline schema contract",
            tests: vec![TestCase {
                id: TestId("ops.load.baselines_schema_valid".to_string()),
                title: "load baselines are parseable and contain required fields",
                kind: TestKind::Pure,
                run: test_ops_load_004_baselines_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-005".to_string()),
            title: "load scenario to slo mapping contract",
            tests: vec![TestCase {
                id: TestId("ops.load.no_scenario_without_slo_mapping".to_string()),
                title: "smoke/pr load suites must be represented in inventory SLO mappings",
                kind: TestKind::Pure,
                run: test_ops_load_005_no_scenario_without_slo_mapping,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-001".to_string()),
            title: "observability alert rules contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.alert_rules_exist_parseable".to_string()),
                title: "required alert rule sources exist and are parseable",
                kind: TestKind::Pure,
                run: test_ops_obs_001_alert_rules_exist_parseable,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-002".to_string()),
            title: "observability dashboard golden contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.dashboard_json_parseable_golden_diff".to_string()),
                title: "dashboard json parses and matches golden identity and panel structure",
                kind: TestKind::Pure,
                run: test_ops_obs_002_dashboard_json_parseable_golden_diff,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-003".to_string()),
            title: "observability telemetry golden profile contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.telemetry_goldens_required_profiles".to_string()),
                title: "telemetry goldens exist for required profiles and are indexed",
                kind: TestKind::Pure,
                run: test_ops_obs_003_telemetry_goldens_required_profiles,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-004".to_string()),
            title: "observability readiness schema contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.readiness_schema_valid".to_string()),
                title: "readiness contract is parseable and uses canonical requirement set",
                kind: TestKind::Pure,
                run: test_ops_obs_004_readiness_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-001".to_string()),
            title: "report schema ssot contract",
            tests: vec![TestCase {
                id: TestId("ops.report.schema_is_ssot".to_string()),
                title: "report schema is parseable and mirrored under ops/schema/report",
                kind: TestKind::Pure,
                run: test_ops_rpt_001_report_schema_ssot,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-002".to_string()),
            title: "report generated payload contract",
            tests: vec![TestCase {
                id: TestId("ops.report.generated_reports_schema_valid".to_string()),
                title: "generated report payloads are parseable and include schema_version",
                kind: TestKind::Pure,
                run: test_ops_rpt_002_generated_reports_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-003".to_string()),
            title: "report evidence levels contract",
            tests: vec![TestCase {
                id: TestId("ops.report.evidence_levels_complete".to_string()),
                title: "evidence levels include minimal standard and forensic",
                kind: TestKind::Pure,
                run: test_ops_rpt_003_evidence_levels_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-004".to_string()),
            title: "report diff structure contract",
            tests: vec![TestCase {
                id: TestId("ops.report.diff_contract_exists".to_string()),
                title: "generated report diff includes base target and change set",
                kind: TestKind::Pure,
                run: test_ops_rpt_004_report_diff_contract_exists,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-001".to_string()),
            title: "stack toml profile contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.stack_toml_parseable_complete".to_string()),
                title: "stack.toml parses and includes canonical ci kind local profiles",
                kind: TestKind::Pure,
                run: test_ops_stack_001_stack_toml_parseable_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-002".to_string()),
            title: "stack service dependency contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.service_dependency_contract_valid".to_string()),
                title: "service dependency contract entries are parseable and resolve to files",
                kind: TestKind::Pure,
                run: test_ops_stack_002_service_dependency_contract_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-003".to_string()),
            title: "stack version manifest contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.versions_manifest_schema_valid".to_string()),
                title: "version manifest is parseable and image refs are digest pinned",
                kind: TestKind::Pure,
                run: test_ops_stack_003_versions_manifest_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-004".to_string()),
            title: "stack dependency graph contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.dependency_graph_generated_acyclic".to_string()),
                title: "dependency graph is parseable and references real cluster/components",
                kind: TestKind::Pure,
                run: test_ops_stack_004_dependency_graph_generated_acyclic,
            }],
        },
    ])
}

pub fn contract_explain(contract_id: &str) -> &'static str {
    match contract_id {
        "OPS-000" => "Defines the only allowed root ops filesystem surface and markdown envelope.",
        "OPS-001" => "Governs generated artifact lifecycle boundaries under _generated and _generated.example.",
        "OPS-002" => "Requires per-domain README/CONTRACT and forbids legacy duplicate docs.",
        "OPS-003" => "Enforces markdown size budgets so contracts stay concise and reviewable.",
        "OPS-004" => "Enforces SSOT boundary: ops README is navigation-only and points to docs/operations.",
        "OPS-INV-001" => "Ensures domain and policy registration completeness in inventory sources.",
        "OPS-INV-002" => "Prevents orphan ops files that are not mapped by inventory references.",
        "OPS-INV-003" => "Forbids duplicate SSOT markdown documents when inventory is authoritative.",
        "OPS-INV-004" => "Enforces authority-tier exception structure with explicit expiry metadata.",
        "OPS-INV-005" => "Validates inventory control-graph integrity, mappings, and cycle safety.",
        "OPS-SCHEMA-001" => "Ensures ops json/yaml policy documents are parseable.",
        "OPS-SCHEMA-002" => "Ensures generated schema index matches on-disk schema sources.",
        "OPS-SCHEMA-003" => "Enforces stable .schema.json naming for schema source files.",
        "OPS-SCHEMA-004" => "Enforces per-domain schema count budgets to limit sprawl.",
        "OPS-SCHEMA-005" => "Requires compatibility lock coverage for schema evolution governance.",
        "OPS-DATASET-001" => "Ensures datasets manifest and lock use the same dataset id set.",
        "OPS-DATASET-002" => "Ensures fixture inventory maps cleanly to fixture directories and references.",
        "OPS-DATASET-003" => "Requires fixture drift to be covered by explicit promotion policy metadata.",
        "OPS-DATASET-004" => "Ensures release-diff fixture assets and goldens stay deterministic and pinned.",
        "OPS-E2E-001" => "Ensures e2e suites map to concrete scenario ids and runnable scripts.",
        "OPS-E2E-002" => "Ensures smoke manifest structure and lock references are valid.",
        "OPS-E2E-003" => "Ensures fixture lock digest and allowlist file policy remain consistent.",
        "OPS-E2E-004" => "Ensures realdata snapshots are parseable and pinned to canonical queries.",
        "OPS-ENV-001" => "Ensures required environment overlays satisfy structural schema rules.",
        "OPS-ENV-002" => "Ensures base/ci/dev/prod overlay coverage and profile identity consistency.",
        "OPS-ENV-003" => "Enforces strict known-key policy for environment overlay payloads.",
        "OPS-K8S-001" => "Ensures helm chart sources expose static render prerequisites.",
        "OPS-K8S-002" => "Ensures install-matrix values files exist and parse against chart schema surface.",
        "OPS-K8S-003" => "Ensures install-matrix covers canonical k8s profile set and file references.",
        "OPS-K8S-004" => "Forbids disallowed cluster-scope object kinds in helm templates.",
        "OPS-LOAD-001" => "Ensures load scenarios are parseable and keep required fields.",
        "OPS-LOAD-002" => "Ensures each load suite has a matching thresholds artifact.",
        "OPS-LOAD-003" => "Ensures pinned query lock digests match source query payload.",
        "OPS-LOAD-004" => "Ensures load baselines are parseable and include required structure.",
        "OPS-LOAD-005" => "Ensures smoke/pr load suites are covered by inventory SLO mappings.",
        "OPS-OBS-001" => "Ensures observability alert rules exist and are parseable.",
        "OPS-OBS-002" => "Ensures observability dashboard json aligns with committed golden identity.",
        "OPS-OBS-003" => "Ensures telemetry goldens for required profiles exist and are indexed.",
        "OPS-OBS-004" => "Ensures readiness contract is parseable and contains canonical requirements.",
        "OPS-RPT-001" => "Ensures report schema is the SSOT and mirrored under ops/schema/report.",
        "OPS-RPT-002" => "Ensures generated report payloads are parseable and include schema_version.",
        "OPS-RPT-003" => "Ensures report evidence levels include minimal standard and forensic tiers.",
        "OPS-RPT-004" => "Ensures generated report diff includes base target and change structure.",
        "OPS-STACK-001" => "Ensures stack.toml parses and defines canonical execution profiles.",
        "OPS-STACK-002" => "Ensures service dependency contract entries are structurally valid.",
        "OPS-STACK-003" => "Ensures stack version manifest is parseable and digest pinned.",
        "OPS-STACK-004" => "Ensures stack dependency graph references real assets and consistent profile links.",
        _ => "No explanation registered for this contract id.",
    }
}
