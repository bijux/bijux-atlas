pub fn contracts(repo_root: &Path) -> Result<Vec<Contract>, String> {
    let rows = vec![
        Contract {
            id: ContractId("OPS-000".to_string()),
            title: "ops directory contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.dir.allowed_root_files".to_string()),
                    title: "ops root allows only contract/readme root files",
                    kind: TestKind::Pure,
                    run: test_ops_000_allowed_root_files,
                },
                TestCase {
                    id: TestId("ops.dir.forbid_extra_markdown_root".to_string()),
                    title: "ops root forbids extra markdown",
                    kind: TestKind::Pure,
                    run: test_ops_000_forbid_extra_markdown_root,
                },
                TestCase {
                    id: TestId("ops.dir.allow_only_known_domain_dirs".to_string()),
                    title: "ops root allows only canonical domain directories",
                    kind: TestKind::Pure,
                    run: test_ops_000_allow_only_known_domain_dirs,
                },
                TestCase {
                    id: TestId("ops.dir.forbid_extra_markdown_recursive".to_string()),
                    title: "ops forbids recursive markdown outside approved surface",
                    kind: TestKind::Pure,
                    run: test_ops_000_forbid_extra_markdown_recursive,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-001".to_string()),
            title: "ops generated lifecycle contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.generated.runtime.allowed_files".to_string()),
                    title: "ops/_generated allows only runtime artifact formats",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_runtime_allowed_files,
                },
                TestCase {
                    id: TestId("ops.generated.example.allowed_files".to_string()),
                    title: "ops/_generated.example allows only committed artifact formats",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_example_allowed_files,
                },
                TestCase {
                    id: TestId("ops.generated.runtime.no_example_files".to_string()),
                    title: "ops/_generated forbids example artifacts",
                    kind: TestKind::Pure,
                    run: test_ops_001_generated_runtime_forbid_example_files,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-002".to_string()),
            title: "ops required domain files contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.domain.required_contract_and_readme".to_string()),
                    title: "each ops domain includes README.md and CONTRACT.md",
                    kind: TestKind::Pure,
                    run: test_ops_002_domain_required_files,
                },
                TestCase {
                    id: TestId("ops.domain.forbid_legacy_docs".to_string()),
                    title: "legacy domain INDEX/OWNER/REQUIRED markdown files are forbidden",
                    kind: TestKind::Pure,
                    run: test_ops_002_forbid_legacy_domain_docs,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-003".to_string()),
            title: "ops markdown budget contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.markdown_budget.readme".to_string()),
                    title: "README markdown files stay within line budget",
                    kind: TestKind::Pure,
                    run: test_ops_003_readme_markdown_budget,
                },
                TestCase {
                    id: TestId("ops.markdown_budget.contract".to_string()),
                    title: "CONTRACT markdown files stay within line budget",
                    kind: TestKind::Pure,
                    run: test_ops_003_contract_markdown_budget,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-004".to_string()),
            title: "ops docs ssot boundary contract",
            tests: vec![TestCase {
                id: TestId("ops.docs.readme_ssot_boundary".to_string()),
                title: "ops root readme remains navigation-only and references docs/operations",
                kind: TestKind::Pure,
                run: test_ops_004_readme_ssot_boundary,
            }],
        },
        Contract {
            id: ContractId("OPS-005".to_string()),
            title: "ops contract document generation contract",
            tests: vec![TestCase {
                id: TestId("ops.contract_doc.generated_match".to_string()),
                title: "ops CONTRACT.md matches generated output from contract registry",
                kind: TestKind::Pure,
                run: test_ops_contract_doc_generated_match,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-001".to_string()),
            title: "ops root allowed surface contract",
            tests: vec![TestCase {
                id: TestId("ops.root.allowed_surface".to_string()),
                title: "ops root contains only canonical files and domain directories",
                kind: TestKind::Pure,
                run: test_ops_root_001_allowed_surface,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-002".to_string()),
            title: "ops root markdown contract",
            tests: vec![TestCase {
                id: TestId("ops.root.forbid_extra_markdown".to_string()),
                title: "ops root forbids markdown files other than README.md and CONTRACT.md",
                kind: TestKind::Pure,
                run: test_ops_root_002_forbid_extra_root_markdown,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-003".to_string()),
            title: "ops no shell scripts contract",
            tests: vec![TestCase {
                id: TestId("ops.root.no_shell_script_files".to_string()),
                title: "ops tree contains no shell script files or bash shebangs",
                kind: TestKind::Pure,
                run: test_ops_root_003_no_shell_script_files,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-004".to_string()),
            title: "ops max directory depth contract",
            tests: vec![TestCase {
                id: TestId("ops.root.max_directory_depth".to_string()),
                title: "ops file paths remain within configured depth budget",
                kind: TestKind::Pure,
                run: test_ops_root_004_max_directory_depth,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-005".to_string()),
            title: "ops filename policy contract",
            tests: vec![TestCase {
                id: TestId("ops.root.filename_policy".to_string()),
                title: "ops filenames follow stable lowercase policy with explicit allowlist exceptions",
                kind: TestKind::Pure,
                run: test_ops_root_005_filename_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-006".to_string()),
            title: "ops generated gitignore policy contract",
            tests: vec![TestCase {
                id: TestId("ops.root.generated_gitignore_policy".to_string()),
                title: "ops/_generated is gitignored with explicit .gitkeep exception",
                kind: TestKind::Pure,
                run: test_ops_root_006_generated_gitignore_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-007".to_string()),
            title: "ops generated example secret guard contract",
            tests: vec![TestCase {
                id: TestId("ops.root.generated_example_secret_guard".to_string()),
                title: "ops/_generated.example is secret-free and json payloads are parseable",
                kind: TestKind::Pure,
                run: test_ops_root_007_generated_example_secret_guard,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-008".to_string()),
            title: "ops placeholder directory contract",
            tests: vec![TestCase {
                id: TestId("ops.root.placeholder_dirs_allowlist".to_string()),
                title: "ops placeholder directories are explicitly allowlisted",
                kind: TestKind::Pure,
                run: test_ops_root_008_placeholder_dirs_allowlist,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-009".to_string()),
            title: "ops policy inventory coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.root.policy_files_inventory_coverage".to_string()),
                title: "ops policy/config files are covered by inventory sources",
                kind: TestKind::Pure,
                run: test_ops_root_009_inventory_coverage_for_policy_files,
            }],
        },
        Contract {
            id: ContractId("OPS-ROOT-010".to_string()),
            title: "ops deleted doc name guard contract",
            tests: vec![TestCase {
                id: TestId("ops.root.forbid_deleted_doc_names".to_string()),
                title: "forbidden legacy ops markdown names must not be reintroduced",
                kind: TestKind::Pure,
                run: test_ops_root_010_forbid_deleted_doc_names,
            }],
        },
        Contract {
            id: ContractId("OPS-DOCS-001".to_string()),
            title: "operations docs policy linkage contract",
            tests: vec![
                TestCase {
                    id: TestId("ops.docs.policy_keyword_requires_contract_id".to_string()),
                    title: "operations docs with policy keywords must reference OPS contract ids",
                    kind: TestKind::Pure,
                    run: test_ops_docs_001_policy_keyword_requires_contract_id,
                },
                TestCase {
                    id: TestId("ops.docs.index_crosslinks_contracts".to_string()),
                    title: "operations index must state docs/contracts boundary and include OPS references",
                    kind: TestKind::Pure,
                    run: test_ops_docs_002_index_crosslinks_contracts,
                },
            ],
        },
        Contract {
            id: ContractId("OPS-INV-001".to_string()),
            title: "inventory completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.completeness".to_string()),
                title: "inventory registers all domains and policy files",
                kind: TestKind::Pure,
                run: test_ops_inv_001_inventory_completeness,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-002".to_string()),
            title: "inventory orphan files contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.no_orphan_files".to_string()),
                title: "ops files must be mapped through inventory sources",
                kind: TestKind::Pure,
                run: test_ops_inv_002_no_orphan_files,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-003".to_string()),
            title: "inventory duplicate source contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.no_duplicate_ssot_sources".to_string()),
                title: "duplicate ssot markdown sources are forbidden",
                kind: TestKind::Pure,
                run: test_ops_inv_003_no_duplicate_ssot,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-004".to_string()),
            title: "inventory authority tier contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.authority_tiers_enforced".to_string()),
                title: "authority tier exceptions are structured and expiry-bound",
                kind: TestKind::Pure,
                run: test_ops_inv_004_authority_tiers_enforced,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-005".to_string()),
            title: "inventory control graph contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.control_graph_validated".to_string()),
                title: "control graph edges and node mappings are valid and acyclic",
                kind: TestKind::Pure,
                run: test_ops_inv_005_control_graph_validated,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-006".to_string()),
            title: "inventory contract id format contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.contract_id_format".to_string()),
                title: "all ops contract ids follow OPS-<PILLAR>-NNN format",
                kind: TestKind::Pure,
                run: test_ops_inv_006_contract_id_format,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-007".to_string()),
            title: "inventory gates registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.gates_registry_mapped".to_string()),
                title: "gates registry exists and maps each gate to one action id",
                kind: TestKind::Pure,
                run: test_ops_inv_007_gates_registry_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-008".to_string()),
            title: "inventory drills registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.drills_registry_mapped".to_string()),
                title: "drills registry ids map to runnable observe drill definitions",
                kind: TestKind::Pure,
                run: test_ops_inv_008_drills_registry_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-009".to_string()),
            title: "inventory owners registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.owners_registry_complete".to_string()),
                title: "owners registry exists and includes all ops domain directories",
                kind: TestKind::Pure,
                run: test_ops_inv_009_owners_registry_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-010".to_string()),
            title: "inventory schema coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.schema_coverage".to_string()),
                title: "inventory schema directory includes required registry schemas",
                kind: TestKind::Pure,
                run: test_ops_inv_010_inventory_schema_coverage,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-PILLARS-001".to_string()),
            title: "inventory pillars registry contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.pillars.exists_and_validates".to_string()),
                title: "pillars.json exists and validates",
                kind: TestKind::Pure,
                run: test_ops_inv_pillars_001_exists_and_validates,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-PILLARS-002".to_string()),
            title: "inventory pillar directory contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.pillars.every_pillar_dir_exists".to_string()),
                title: "every declared non-root pillar has a matching ops directory",
                kind: TestKind::Pure,
                run: test_ops_inv_pillars_002_every_pillar_dir_exists,
            }],
        },
        Contract {
            id: ContractId("OPS-INV-PILLARS-003".to_string()),
            title: "inventory pillar strictness contract",
            tests: vec![TestCase {
                id: TestId("ops.inventory.pillars.no_extra_pillar_dirs".to_string()),
                title: "ops root has no undeclared pillar directories",
                kind: TestKind::Pure,
                run: test_ops_inv_pillars_003_no_extra_pillar_dirs,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-001".to_string()),
            title: "schema parseability contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.parseable_documents".to_string()),
                title: "ops json/yaml policy documents are parseable",
                kind: TestKind::Pure,
                run: test_ops_schema_001_parseable_documents,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-002".to_string()),
            title: "schema index completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.index_complete".to_string()),
                title: "generated schema index covers all schema sources",
                kind: TestKind::Pure,
                run: test_ops_schema_002_schema_index_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-003".to_string()),
            title: "schema naming contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.no_unversioned".to_string()),
                title: "schema sources use stable .schema.json naming",
                kind: TestKind::Pure,
                run: test_ops_schema_003_no_unversioned_schemas,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-004".to_string()),
            title: "schema budget contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.budget_policy".to_string()),
                title: "schema count stays within per-domain budgets",
                kind: TestKind::Pure,
                run: test_ops_schema_004_budget_policy,
            }],
        },
        Contract {
            id: ContractId("OPS-SCHEMA-005".to_string()),
            title: "schema evolution lock contract",
            tests: vec![TestCase {
                id: TestId("ops.schema.evolution_lock".to_string()),
                title: "compatibility lock tracks schema evolution targets",
                kind: TestKind::Pure,
                run: test_ops_schema_005_evolution_lock,
            }],
        },
        Contract { id: ContractId("OPS-SCHEMA-006".to_string()), title: "schema id consistency contract", tests: vec![TestCase { id: TestId("ops.schema.id_and_naming_consistency".to_string()), title: "schema files define stable $id values aligned with file names", kind: TestKind::Pure, run: test_ops_schema_006_id_and_naming_consistency, }] },
        Contract { id: ContractId("OPS-SCHEMA-007".to_string()), title: "schema example validation contract", tests: vec![TestCase { id: TestId("ops.schema.examples_validate_required_fields".to_string()), title: "schema examples satisfy required field coverage from compatibility lock", kind: TestKind::Pure, run: test_ops_schema_007_examples_validate_required_fields, }] },
        Contract { id: ContractId("OPS-SCHEMA-008".to_string()), title: "schema intent uniqueness contract", tests: vec![TestCase { id: TestId("ops.schema.forbid_duplicate_intent".to_string()), title: "schema ids and titles are unique to avoid duplicated intent", kind: TestKind::Pure, run: test_ops_schema_008_forbid_duplicate_schema_intent, }] },
        Contract { id: ContractId("OPS-SCHEMA-009".to_string()), title: "schema canonical formatting contract", tests: vec![TestCase { id: TestId("ops.schema.canonical_json_formatting".to_string()), title: "generated schema artifacts use canonical pretty json formatting", kind: TestKind::Pure, run: test_ops_schema_009_canonical_json_formatting, }] },
        Contract { id: ContractId("OPS-SCHEMA-010".to_string()), title: "schema example coverage contract", tests: vec![TestCase { id: TestId("ops.schema.example_coverage".to_string()), title: "schema compatibility targets declare existing example fixtures", kind: TestKind::Pure, run: test_ops_schema_010_example_coverage, }] },
        Contract {
            id: ContractId("OPS-DATASET-001".to_string()),
            title: "datasets manifest lock contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.manifest_and_lock_consistent".to_string()),
                title: "dataset manifest and lock ids are consistent",
                kind: TestKind::Pure,
                run: test_ops_dataset_001_manifest_and_lock,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-002".to_string()),
            title: "datasets fixture inventory contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.fixture_inventory_matches_disk".to_string()),
                title: "fixture inventory matches fixture directories and references",
                kind: TestKind::Pure,
                run: test_ops_dataset_002_fixture_inventory_matches_disk,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-003".to_string()),
            title: "datasets fixture drift promotion contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.no_fixture_drift_without_promotion_record".to_string()),
                title: "fixture drift requires explicit promotion rule coverage",
                kind: TestKind::Pure,
                run: test_ops_dataset_003_no_fixture_drift_without_promotion_record,
            }],
        },
        Contract {
            id: ContractId("OPS-DATASET-004".to_string()),
            title: "datasets release diff determinism contract",
            tests: vec![TestCase {
                id: TestId("ops.dataset.release_diff_fixtures_deterministic".to_string()),
                title: "release-diff fixture lock and golden payloads are deterministic",
                kind: TestKind::Pure,
                run: test_ops_dataset_004_release_diff_fixtures_are_deterministic,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-001".to_string()),
            title: "e2e suites reference contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.suites_reference_real_scenarios".to_string()),
                title: "e2e suites reference concrete scenario ids and runnable entrypoints",
                kind: TestKind::Pure,
                run: test_ops_e2e_001_suites_reference_real_scenarios,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-002".to_string()),
            title: "e2e smoke manifest contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.smoke_manifest_valid".to_string()),
                title: "smoke manifest is structured and points to existing lock",
                kind: TestKind::Pure,
                run: test_ops_e2e_002_smoke_manifest_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-003".to_string()),
            title: "e2e fixtures lock contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.fixtures_lock_matches_allowlist".to_string()),
                title: "fixtures lock digest and fixture files match allowlist policy",
                kind: TestKind::Pure,
                run: test_ops_e2e_003_fixtures_lock_matches_allowlist,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-004".to_string()),
            title: "e2e realdata snapshot contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.realdata_snapshots_schema_valid_and_pinned".to_string()),
                title: "realdata snapshots are parseable and pinned to canonical queries",
                kind: TestKind::Pure,
                run: test_ops_e2e_004_realdata_snapshots_schema_valid_and_pinned,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-001".to_string()),
            title: "environment overlay schema contract",
            tests: vec![TestCase {
                id: TestId("ops.env.overlays_schema_valid".to_string()),
                title: "all required environment overlays are structurally valid",
                kind: TestKind::Pure,
                run: test_ops_env_001_overlays_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-002".to_string()),
            title: "environment profile completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.env.profiles_complete".to_string()),
                title: "base/ci/dev/prod overlays exist and match profile identity",
                kind: TestKind::Pure,
                run: test_ops_env_002_env_profiles_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-ENV-003".to_string()),
            title: "environment key strictness contract",
            tests: vec![TestCase {
                id: TestId("ops.env.no_unknown_keys".to_string()),
                title: "environment overlays reject unknown keys",
                kind: TestKind::Pure,
                run: test_ops_env_003_no_unknown_keys,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-001".to_string()),
            title: "k8s static chart render contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.chart_renders_static".to_string()),
                title: "helm chart source includes required files and static render inputs",
                kind: TestKind::Pure,
                run: test_ops_k8s_001_chart_renders_static,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-002".to_string()),
            title: "k8s values schema validation contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.values_files_validate_schema".to_string()),
                title: "install-matrix values files exist and are parseable against chart schema surface",
                kind: TestKind::Pure,
                run: test_ops_k8s_002_values_files_validate_schema,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-003".to_string()),
            title: "k8s install matrix completeness contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.install_matrix_complete".to_string()),
                title: "install matrix covers canonical profile set and references existing files",
                kind: TestKind::Pure,
                run: test_ops_k8s_003_install_matrix_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-004".to_string()),
            title: "k8s forbidden object policy contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.no_forbidden_k8s_objects".to_string()),
                title: "helm templates must not introduce forbidden cluster-scope object kinds",
                kind: TestKind::Pure,
                run: test_ops_k8s_004_no_forbidden_k8s_objects,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-001".to_string()),
            title: "load scenario schema contract",
            tests: vec![TestCase {
                id: TestId("ops.load.scenarios_schema_valid".to_string()),
                title: "load scenarios are parseable and include required fields",
                kind: TestKind::Pure,
                run: test_ops_load_001_scenarios_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-002".to_string()),
            title: "load thresholds coverage contract",
            tests: vec![TestCase {
                id: TestId("ops.load.thresholds_exist_for_each_suite".to_string()),
                title: "every load suite has a matching thresholds file",
                kind: TestKind::Pure,
                run: test_ops_load_002_thresholds_exist_for_each_suite,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-003".to_string()),
            title: "load pinned query lock contract",
            tests: vec![TestCase {
                id: TestId("ops.load.pinned_queries_lock_consistent".to_string()),
                title: "pinned query lock digests match source query payload",
                kind: TestKind::Pure,
                run: test_ops_load_003_pinned_queries_lock_consistent,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-004".to_string()),
            title: "load baseline schema contract",
            tests: vec![TestCase {
                id: TestId("ops.load.baselines_schema_valid".to_string()),
                title: "load baselines are parseable and contain required fields",
                kind: TestKind::Pure,
                run: test_ops_load_004_baselines_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-005".to_string()),
            title: "load scenario to slo mapping contract",
            tests: vec![TestCase {
                id: TestId("ops.load.no_scenario_without_slo_mapping".to_string()),
                title: "smoke/pr load suites must be represented in inventory SLO mappings",
                kind: TestKind::Pure,
                run: test_ops_load_005_no_scenario_without_slo_mapping,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-001".to_string()),
            title: "observability alert rules contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.alert_rules_exist_parseable".to_string()),
                title: "required alert rule sources exist and are parseable",
                kind: TestKind::Pure,
                run: test_ops_obs_001_alert_rules_exist_parseable,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-002".to_string()),
            title: "observability dashboard golden contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.dashboard_json_parseable_golden_diff".to_string()),
                title: "dashboard json parses and matches golden identity and panel structure",
                kind: TestKind::Pure,
                run: test_ops_obs_002_dashboard_json_parseable_golden_diff,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-003".to_string()),
            title: "observability telemetry golden profile contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.telemetry_goldens_required_profiles".to_string()),
                title: "telemetry goldens exist for required profiles and are indexed",
                kind: TestKind::Pure,
                run: test_ops_obs_003_telemetry_goldens_required_profiles,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-004".to_string()),
            title: "observability readiness schema contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.readiness_schema_valid".to_string()),
                title: "readiness contract is parseable and uses canonical requirement set",
                kind: TestKind::Pure,
                run: test_ops_obs_004_readiness_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-001".to_string()),
            title: "report schema ssot contract",
            tests: vec![TestCase {
                id: TestId("ops.report.schema_is_ssot".to_string()),
                title: "report schema is parseable and mirrored under ops/schema/report",
                kind: TestKind::Pure,
                run: test_ops_rpt_001_report_schema_ssot,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-002".to_string()),
            title: "report generated payload contract",
            tests: vec![TestCase {
                id: TestId("ops.report.generated_reports_schema_valid".to_string()),
                title: "generated report payloads are parseable and include schema_version",
                kind: TestKind::Pure,
                run: test_ops_rpt_002_generated_reports_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-003".to_string()),
            title: "report evidence levels contract",
            tests: vec![TestCase {
                id: TestId("ops.report.evidence_levels_complete".to_string()),
                title: "evidence levels include minimal standard and forensic",
                kind: TestKind::Pure,
                run: test_ops_rpt_003_evidence_levels_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-RPT-004".to_string()),
            title: "report diff structure contract",
            tests: vec![TestCase {
                id: TestId("ops.report.diff_contract_exists".to_string()),
                title: "generated report diff includes base target and change set",
                kind: TestKind::Pure,
                run: test_ops_rpt_004_report_diff_contract_exists,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-001".to_string()),
            title: "stack toml profile contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.stack_toml_parseable_complete".to_string()),
                title: "stack.toml parses and includes canonical ci kind local profiles",
                kind: TestKind::Pure,
                run: test_ops_stack_001_stack_toml_parseable_complete,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-002".to_string()),
            title: "stack service dependency contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.service_dependency_contract_valid".to_string()),
                title: "service dependency contract entries are parseable and resolve to files",
                kind: TestKind::Pure,
                run: test_ops_stack_002_service_dependency_contract_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-003".to_string()),
            title: "stack version manifest contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.versions_manifest_schema_valid".to_string()),
                title: "version manifest is parseable and image refs are digest pinned",
                kind: TestKind::Pure,
                run: test_ops_stack_003_versions_manifest_schema_valid,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-004".to_string()),
            title: "stack dependency graph contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.dependency_graph_generated_acyclic".to_string()),
                title: "dependency graph is parseable and references real cluster/components",
                kind: TestKind::Pure,
                run: test_ops_stack_004_dependency_graph_generated_acyclic,
            }],
        },
        Contract { id: ContractId("OPS-STACK-005".to_string()), title: "stack kind profile consistency contract", tests: vec![TestCase { id: TestId("ops.stack.kind_profiles_consistent".to_string()), title: "dev perf and small kind profiles exist and reference valid cluster configs", kind: TestKind::Pure, run: test_ops_stack_005_kind_profiles_consistent, }] },
        Contract { id: ContractId("OPS-STACK-006".to_string()), title: "stack ports inventory consistency contract", tests: vec![TestCase { id: TestId("ops.stack.ports_inventory_matches_stack".to_string()), title: "ports inventory endpoints are unique and aligned with stack components", kind: TestKind::Pure, run: test_ops_stack_006_ports_inventory_matches_stack, }] },
        Contract { id: ContractId("OPS-STACK-007".to_string()), title: "stack health report generator contract", tests: vec![TestCase { id: TestId("ops.stack.health_report_generator_contract".to_string()), title: "health report sample has schema envelope and stack generator provenance", kind: TestKind::Pure, run: test_ops_stack_007_health_report_generator_contract, }] },
        Contract { id: ContractId("OPS-STACK-008".to_string()), title: "stack command surface contract", tests: vec![TestCase { id: TestId("ops.stack.stack_commands_registered".to_string()), title: "stack command surface snapshot contains up and down verbs", kind: TestKind::Pure, run: test_ops_stack_008_stack_commands_registered, }] },
        Contract { id: ContractId("OPS-STACK-009".to_string()), title: "stack offline profile policy contract", tests: vec![TestCase { id: TestId("ops.stack.offline_profile_policy".to_string()), title: "offline claims require offline or airgap profile coverage", kind: TestKind::Pure, run: test_ops_stack_009_offline_profile_policy, }] },
        Contract {
            id: ContractId("OPS-STACK-E-001".to_string()),
            title: "stack effect kind cluster contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.kind_cluster_up_profile_dev".to_string()),
                title: "effect lane requires kind dev cluster contract inputs",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_001_kind_cluster_up_profile_dev,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-E-002".to_string()),
            title: "stack effect component rollout contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.core_components_present".to_string()),
                title: "effect lane requires core stack component manifests",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_002_core_components_present,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-E-003".to_string()),
            title: "stack effect ports inventory contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.ports_inventory_mapped".to_string()),
                title: "effect lane requires stack ports inventory contract sample",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_003_ports_inventory_mapped,
            }],
        },
        Contract {
            id: ContractId("OPS-STACK-E-004".to_string()),
            title: "stack effect health report contract",
            tests: vec![TestCase {
                id: TestId("ops.stack.effect.health_report_generated".to_string()),
                title: "effect lane requires stack health report contract sample",
                kind: TestKind::Subprocess,
                run: test_ops_stack_e_004_stack_health_report_generated,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-E-001".to_string()),
            title: "k8s effect helm install contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.effect.helm_install_contract_defined".to_string()),
                title: "effect lane requires kind install profile in k8s install matrix",
                kind: TestKind::Subprocess,
                run: test_ops_k8s_e_001_helm_install_contract_defined,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-E-002".to_string()),
            title: "k8s effect rollout safety contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.effect.rollout_safety_contract_satisfied".to_string()),
                title: "effect lane requires rollout safety contract checks",
                kind: TestKind::Subprocess,
                run: test_ops_k8s_e_002_rollout_safety_contract_satisfied,
            }],
        },
        Contract {
            id: ContractId("OPS-K8S-E-003".to_string()),
            title: "k8s effect endpoint reachability contract",
            tests: vec![TestCase {
                id: TestId("ops.k8s.effect.service_endpoints_reachable_contract".to_string()),
                title: "effect lane requires non-empty k8s suite coverage for endpoint checks",
                kind: TestKind::Network,
                run: test_ops_k8s_e_003_service_endpoints_reachable_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-E-001".to_string()),
            title: "observe effect metrics scrape contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.effect.scrape_metrics_contract".to_string()),
                title: "effect lane requires non-empty metrics scrape contract",
                kind: TestKind::Network,
                run: test_ops_obs_e_001_scrape_metrics_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-E-002".to_string()),
            title: "observe effect trace structure contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.effect.trace_structure_contract".to_string()),
                title: "effect lane requires trace structure golden contract",
                kind: TestKind::Network,
                run: test_ops_obs_e_002_trace_structure_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-OBS-E-003".to_string()),
            title: "observe effect alerts load contract",
            tests: vec![TestCase {
                id: TestId("ops.observe.effect.alerts_load_contract".to_string()),
                title: "effect lane requires parseable alert rule inputs",
                kind: TestKind::Network,
                run: test_ops_obs_e_003_alerts_load_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-E-001".to_string()),
            title: "load effect k6 execution contract",
            tests: vec![TestCase {
                id: TestId("ops.load.effect.k6_suite_executes_contract".to_string()),
                title: "effect lane requires at least one k6 load suite definition",
                kind: TestKind::Subprocess,
                run: test_ops_load_e_001_k6_suite_executes_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-E-002".to_string()),
            title: "load effect thresholds report contract",
            tests: vec![TestCase {
                id: TestId("ops.load.effect.thresholds_enforced_report_emitted".to_string()),
                title: "effect lane requires thresholds contract and emitted load summary report",
                kind: TestKind::Subprocess,
                run: test_ops_load_e_002_thresholds_enforced_report_emitted,
            }],
        },
        Contract {
            id: ContractId("OPS-LOAD-E-003".to_string()),
            title: "load effect baseline comparison contract",
            tests: vec![TestCase {
                id: TestId("ops.load.effect.baseline_comparison_produced".to_string()),
                title: "effect lane requires emitted load drift comparison report",
                kind: TestKind::Subprocess,
                run: test_ops_load_e_003_baseline_comparison_produced,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-E-001".to_string()),
            title: "e2e effect smoke suite contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.effect.smoke_suite_passes_contract".to_string()),
                title: "effect lane requires smoke suite declaration in e2e suite registry",
                kind: TestKind::Subprocess,
                run: test_ops_e2e_e_001_smoke_suite_passes_contract,
            }],
        },
        Contract {
            id: ContractId("OPS-E2E-E-002".to_string()),
            title: "e2e effect realdata suite contract",
            tests: vec![TestCase {
                id: TestId("ops.e2e.effect.realdata_scenario_passes_contract".to_string()),
                title: "effect lane requires non-empty realdata scenario contract set",
                kind: TestKind::Subprocess,
                run: test_ops_e2e_e_002_realdata_scenario_passes_contract,
            }],
        },
    ];
    validate_registry(&rows, repo_root)?;
    Ok(rows)
}

pub fn contract_explain(contract_id: &str) -> &'static str {
    match contract_id {
        "OPS-000" => "Defines the only allowed root ops filesystem surface and markdown envelope.",
        "OPS-001" => "Governs generated artifact lifecycle boundaries under _generated and _generated.example.",
        "OPS-002" => "Requires per-domain README/CONTRACT and forbids legacy duplicate docs.",
        "OPS-003" => "Enforces markdown size budgets so contracts stay concise and reviewable.",
        "OPS-004" => "Enforces SSOT boundary: ops README is navigation-only and points to docs/operations.",
        "OPS-005" => "Ensures ops/CONTRACT.md is generated from and synchronized with registry metadata.",
        "OPS-ROOT-001" => "Constrains ops root surface to canonical control-plane files and domain directories.",
        "OPS-ROOT-002" => "Forbids extra markdown documents at ops root beyond README.md and CONTRACT.md.",
        "OPS-ROOT-003" => "Forbids shell script artifacts and bash shebangs in ops policy/config trees.",
        "OPS-ROOT-004" => "Enforces directory-depth budget for ops artifacts to avoid uncontrolled nesting.",
        "OPS-ROOT-005" => "Enforces stable filename policy with explicit allowlisted exceptions.",
        "OPS-ROOT-006" => "Requires gitignore policy for runtime-generated ops/_generated artifacts.",
        "OPS-ROOT-007" => "Guards committed generated examples against secret-like payload leakage.",
        "OPS-ROOT-008" => "Requires placeholder directories to be explicitly listed in inventory allowlist.",
        "OPS-ROOT-009" => "Requires ops policy/config artifacts to be covered by inventory mappings.",
        "OPS-ROOT-010" => "Prevents reintroduction of deleted legacy ops markdown policy documents.",
        "OPS-DOCS-001" => "Ensures operations docs policy statements reference executable OPS contract IDs.",
        "OPS-INV-001" => "Ensures domain and policy registration completeness in inventory sources.",
        "OPS-INV-002" => "Prevents orphan ops files that are not mapped by inventory references.",
        "OPS-INV-003" => "Forbids duplicate SSOT markdown documents when inventory is authoritative.",
        "OPS-INV-004" => "Enforces authority-tier exception structure with explicit expiry metadata.",
        "OPS-INV-005" => "Validates inventory control-graph integrity, mappings, and cycle safety.",
        "OPS-INV-006" => "Validates contract id format consistency in the ops contract registry.",
        "OPS-INV-007" => "Ensures gates registry exists with one unique mapped action per gate id.",
        "OPS-INV-008" => "Ensures drills registry ids map to runnable observability drill definitions.",
        "OPS-INV-009" => "Ensures owners registry covers each canonical ops domain directory.",
        "OPS-INV-010" => "Ensures required inventory schema files exist under ops/schema/inventory.",
        "OPS-INV-PILLARS-001" => "Validates pillars SSOT exists and parses as inventory metadata.",
        "OPS-INV-PILLARS-002" => "Validates each declared pillar has a concrete directory under ops/.",
        "OPS-INV-PILLARS-003" => "Validates there are no undeclared pillar directories in ops root.",
        "OPS-SCHEMA-001" => "Ensures ops json/yaml policy documents are parseable.",
        "OPS-SCHEMA-002" => "Ensures generated schema index matches on-disk schema sources.",
        "OPS-SCHEMA-003" => "Enforces stable .schema.json naming for schema source files.",
        "OPS-SCHEMA-004" => "Enforces per-domain schema count budgets to limit sprawl.",
        "OPS-SCHEMA-005" => "Requires compatibility lock coverage for schema evolution governance.",
        "OPS-SCHEMA-006" => "Ensures schema files declare stable $id values aligned with file names.",
        "OPS-SCHEMA-007" => "Ensures schema examples cover required fields declared in compatibility lock.",
        "OPS-SCHEMA-008" => "Prevents duplicate schema $id or title intent across schema sources.",
        "OPS-SCHEMA-009" => "Enforces canonical pretty JSON formatting for generated schema artifacts.",
        "OPS-SCHEMA-010" => "Ensures each compatibility-lock schema target declares an existing example fixture.",
        "OPS-DATASET-001" => "Ensures datasets manifest and lock use the same dataset id set.",
        "OPS-DATASET-002" => "Ensures fixture inventory maps cleanly to fixture directories and references.",
        "OPS-DATASET-003" => "Requires fixture drift to be covered by explicit promotion policy metadata.",
        "OPS-DATASET-004" => "Ensures release-diff fixture assets and goldens stay deterministic and pinned.",
        "OPS-E2E-001" => "Ensures e2e suites map to concrete scenario ids and runnable scripts.",
        "OPS-E2E-002" => "Ensures smoke manifest structure and lock references are valid.",
        "OPS-E2E-003" => "Ensures fixture lock digest and allowlist file policy remain consistent.",
        "OPS-E2E-004" => "Ensures realdata snapshots are parseable and pinned to canonical queries.",
        "OPS-ENV-001" => "Ensures required environment overlays satisfy structural schema rules.",
        "OPS-ENV-002" => "Ensures base/ci/dev/prod overlay coverage and profile identity consistency.",
        "OPS-ENV-003" => "Enforces strict known-key policy for environment overlay payloads.",
        "OPS-K8S-001" => "Ensures helm chart sources expose static render prerequisites.",
        "OPS-K8S-002" => "Ensures install-matrix values files exist and parse against chart schema surface.",
        "OPS-K8S-003" => "Ensures install-matrix covers canonical k8s profile set and file references.",
        "OPS-K8S-004" => "Forbids disallowed cluster-scope object kinds in helm templates.",
        "OPS-LOAD-001" => "Ensures load scenarios are parseable and keep required fields.",
        "OPS-LOAD-002" => "Ensures each load suite has a matching thresholds artifact.",
        "OPS-LOAD-003" => "Ensures pinned query lock digests match source query payload.",
        "OPS-LOAD-004" => "Ensures load baselines are parseable and include required structure.",
        "OPS-LOAD-005" => "Ensures smoke/pr load suites are covered by inventory SLO mappings.",
        "OPS-OBS-001" => "Ensures observability alert rules exist and are parseable.",
        "OPS-OBS-002" => "Ensures observability dashboard json aligns with committed golden identity.",
        "OPS-OBS-003" => "Ensures telemetry goldens for required profiles exist and are indexed.",
        "OPS-OBS-004" => "Ensures readiness contract is parseable and contains canonical requirements.",
        "OPS-RPT-001" => "Ensures report schema is the SSOT and mirrored under ops/schema/report.",
        "OPS-RPT-002" => "Ensures generated report payloads are parseable and include schema_version.",
        "OPS-RPT-003" => "Ensures report evidence levels include minimal standard and forensic tiers.",
        "OPS-RPT-004" => "Ensures generated report diff includes base target and change structure.",
        "OPS-STACK-001" => "Ensures stack.toml parses and defines canonical execution profiles.",
        "OPS-STACK-002" => "Ensures service dependency contract entries are structurally valid.",
        "OPS-STACK-003" => "Ensures stack version manifest is parseable and digest pinned.",
        "OPS-STACK-004" => "Ensures stack dependency graph references real assets and consistent profile links.",
        "OPS-STACK-005" => "Ensures dev/perf/small kind profile coverage and required cluster config fields.",
        "OPS-STACK-006" => "Ensures stack ports inventory endpoint mapping is unique and component-aware.",
        "OPS-STACK-007" => "Ensures stack health report evidence carries schema envelope and generator provenance.",
        "OPS-STACK-008" => "Ensures stack up/down verbs remain present in control-plane command surface snapshot.",
        "OPS-STACK-009" => "Ensures offline or airgap claims are backed by explicit stack profile entries.",
        "OPS-STACK-E-001" => "Effect lane contract for kind dev cluster bring-up inputs.",
        "OPS-STACK-E-002" => "Effect lane contract for core stack component rollout manifests.",
        "OPS-STACK-E-003" => "Effect lane contract for stack ports inventory mapping evidence.",
        "OPS-STACK-E-004" => "Effect lane contract for stack health report evidence.",
        "OPS-K8S-E-001" => "Effect lane contract for helm install profile coverage in k8s matrix.",
        "OPS-K8S-E-002" => "Effect lane contract for rollout safety checks declaration.",
        "OPS-K8S-E-003" => "Effect lane contract for service endpoint reachability suite coverage.",
        "OPS-OBS-E-001" => "Effect lane contract for metrics scrape evidence input.",
        "OPS-OBS-E-002" => "Effect lane contract for trace structure evidence input.",
        "OPS-OBS-E-003" => "Effect lane contract for alert rule loading inputs.",
        "OPS-LOAD-E-001" => "Effect lane contract for executable k6 load suite coverage.",
        "OPS-LOAD-E-002" => "Effect lane contract for threshold enforcement and load summary emission.",
        "OPS-LOAD-E-003" => "Effect lane contract for emitted load baseline drift comparison.",
        "OPS-E2E-E-001" => "Effect lane contract for smoke suite declaration in e2e registry.",
        "OPS-E2E-E-002" => "Effect lane contract for realdata scenario declaration in e2e registry.",
        _ => "No explanation registered for this contract id.",
    }
}
